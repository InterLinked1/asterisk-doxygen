<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Asterisk - The Open Source Telephony Project: Stasis Message Bus API</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Asterisk - The Open Source Telephony Project
   &#160;<span id="projectnumber">18.5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Stasis Message Bus API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section user"><dt>Intro</dt><dd></dd></dl>
<p>The Stasis Message Bus is a loosely typed mechanism for distributing messages within Asterisk. It is designed to be:</p><ul>
<li>Loosely coupled; new message types can be added in seperate modules.</li>
<li>Easy to use; publishing and subscribing are straightforward operations.</li>
</ul>
<p>There are three main concepts for using the Stasis Message Bus:</p><ul>
<li><a class="el" href="../../d7/d55/structstasis__message.html">stasis_message</a></li>
<li><a class="el" href="../../d9/d1d/structstasis__topic.html">stasis_topic</a></li>
<li><a class="el" href="../../d9/de4/structstasis__subscription.html">stasis_subscription</a></li>
</ul>
<dl class="section user"><dt>stasis_message</dt><dd></dd></dl>
<p>Central to the Stasis Message Bus is the <a class="el" href="../../d7/d55/structstasis__message.html">stasis_message</a>, the messages that are sent on the bus. These messages have:</p><ul>
<li>a type (as defined by a <a class="el" href="../../d4/d8f/structstasis__message__type.html">stasis_message_type</a>)</li>
<li>a value - a <code>void</code> pointer to an AO2 object</li>
<li>a timestamp when it was created</li>
</ul>
<p>Once a <a class="el" href="../../d7/d55/structstasis__message.html">stasis_message</a> has been created, it is immutable and cannot change. The same goes for the value of the message (although this cannot be enforced in code). Messages themselves are reference-counted, AO2 objects, along with their values. By being both reference counted and immutable, messages can be shared throughout the system without any concerns for threading.</p>
<p>The type of a message is defined by an instance of <a class="el" href="../../d4/d8f/structstasis__message__type.html">stasis_message_type</a>, which can be created by calling <a class="el" href="../../dd/d79/stasis_8h.html#a7c7761ce3c78b45fd34cb25bf0e1ba09" title="Create a new message type. ">stasis_message_type_create()</a>. Message types are named, which is useful in debugging. It is recommended that the string name for a message type match the name of the struct that's stored in the message. For example, name for <a class="el" href="../../de/dfa/structstasis__cache__update.html">stasis_cache_update</a>'s message type is <code>"stasis_cache_update"</code>.</p>
<dl class="section user"><dt>stasis_topic</dt><dd></dd></dl>
<p>A <a class="el" href="../../d9/d1d/structstasis__topic.html">stasis_topic</a> is an object to which stasis_subscriber's may be subscribed, and <a class="el" href="../../d7/d55/structstasis__message.html">stasis_message</a>'s may be published. Any message published to the topic is dispatched to all of its subscribers. The topic itself may be named, which is useful in debugging.</p>
<p>Topics themselves are reference counted objects. Since topics are referred to by their subscibers, they will not be freed until all of their subscribers have unsubscribed. Topics are also thread safe, so no worries about publishing/subscribing/unsubscribing to a topic concurrently from multiple threads. It's also designed to handle the case of unsubscribing from a topic from within the subscription handler.</p>
<dl class="section user"><dt>Forwarding</dt><dd></dd></dl>
<p>There is one special case of topics that's worth noting: forwarding messages. It's a fairly common use case to want to forward all the messages published on one topic to another one (for example, an aggregator topic that publishes all the events from a set of other topics). This can be accomplished easily using <a class="el" href="../../dd/d79/stasis_8h.html#a2513a93567ddc93510f7896b777da119" title="Create a subscription which forwards all messages from one topic to another. ">stasis_forward_all()</a>. This sets up the forwarding between the two topics, and returns a <a class="el" href="../../d9/de4/structstasis__subscription.html">stasis_subscription</a>, which can be unsubscribed to stop the forwarding.</p>
<dl class="section user"><dt>Caching</dt><dd></dd></dl>
<p>Another common use case is to want to cache certain messages that are published on the bus. Usually these events are snapshots of the current state in the system, and it's desirable to query that state from the cache without locking the original object. It's also desirable for subscribers of the caching topic to receive messages that have both the old cache value and the new value being put into the cache. For this, we have <a class="el" href="../../dd/d79/stasis_8h.html#a64035c0f7317db2590817a173d268ff1" title="Create a cache. ">stasis_cache_create()</a> and <a class="el" href="../../dd/d79/stasis_8h.html#a4290101180caea800a0461017a167120" title="Create a topic which monitors and caches messages from another topic. ">stasis_caching_topic_create()</a>, providing them with the topic which publishes the messages that you wish to cache, and a function that can identify cacheable messages.</p>
<p>The <a class="el" href="../../dd/d25/structstasis__cache.html">stasis_cache</a> is designed so that it may be shared amongst several <a class="el" href="../../d3/de2/structstasis__caching__topic.html">stasis_caching_topic</a> objects. This allows you to have individual caching topics per-object (i.e. so you can subscribe to updates for a single object), and still have a single cache to query for the state of all objects. While a cache may be shared amongst different message types, such a usage is probably not a good idea.</p>
<p>The <a class="el" href="../../dd/d25/structstasis__cache.html">stasis_cache</a> can only be written to by stasis_caching_topics. It's a thread safe container, so freely use the <a class="el" href="../../dd/d79/stasis_8h.html#ab3da17290725793258020b83f56e4df6" title="Retrieve an item from the cache for the ast_eid_default entity. ">stasis_cache_get()</a> and <a class="el" href="../../dd/d79/stasis_8h.html#a8c5612920b22beb93b5e8acbdae40078" title="Dump cached items to a subscription for the ast_eid_default entity. ">stasis_cache_dump()</a> to query the cache.</p>
<p>The <a class="el" href="../../d3/de2/structstasis__caching__topic.html">stasis_caching_topic</a> discards non-cacheable messages. A cacheable message is wrapped in a <a class="el" href="../../de/dfa/structstasis__cache__update.html">stasis_cache_update</a> message which provides the old snapshot (or <code>NULL</code> if this is a new cache entry), and the new snapshot (or <code>NULL</code> if the entry was removed from the cache). A <a class="el" href="../../dd/d79/stasis_8h.html#a169e12055004ecf0ecc355b3e3e1f218" title="A message which instructs the caching topic to remove an entry from its cache. ">stasis_cache_clear_create()</a> message must be sent to the topic in order to remove entries from the cache.</p>
<p>In order to unsubscribe a <a class="el" href="../../d3/de2/structstasis__caching__topic.html">stasis_caching_topic</a> from the upstream topic, call <a class="el" href="../../dd/d79/stasis_8h.html#afdc3370e3a15daaa00179f2f72ab8c9d" title="Unsubscribes a caching topic from its upstream topic. ">stasis_caching_unsubscribe()</a>. Due to cyclic references, the <a class="el" href="../../d3/de2/structstasis__caching__topic.html">stasis_caching_topic</a> will not be freed until after it has been unsubscribed, and all other <a class="el" href="../../d5/da5/astobj2_8h.html#aaca5e8eac39a22f9da1c36fc6c922270">ao2_ref()</a>'s have been cleaned up.</p>
<p>The <a class="el" href="../../dd/d25/structstasis__cache.html">stasis_cache</a> object is a normal AO2 managed object, which can be release with <a class="el" href="../../d5/da5/astobj2_8h.html#a6321ee982370c55ab3c24c72c562cbdd">ao2_cleanup()</a>.</p>
<dl class="section user"><dt>stasis_subscriber</dt><dd></dd></dl>
<p>Any topic may be subscribed to by simply providing <a class="el" href="../../dd/d79/stasis_8h.html#ae3fe7fe099389094244002113814ec23">stasis_subscribe()</a> the <a class="el" href="../../d9/d1d/structstasis__topic.html">stasis_topic</a> to subscribe to, a handler function and <code>void</code> pointer to data that is passed back to the handler. Invocations on the subscription's handler are serialized, but different invocations may occur on different threads (this usually isn't important unless you use thread locals or something similar).</p>
<p>In order to stop receiving messages, call <a class="el" href="../../dd/d79/stasis_8h.html#a3498301077e2005383f0d261c471388b" title="Cancel a subscription. ">stasis_unsubscribe()</a> with your <a class="el" href="../../d9/de4/structstasis__subscription.html">stasis_subscription</a>. Due to cyclic references, the <a class="el" href="../../d9/de4/structstasis__subscription.html">stasis_subscription</a> will not be freed until after it has been unsubscribed, and all other <a class="el" href="../../d5/da5/astobj2_8h.html#aaca5e8eac39a22f9da1c36fc6c922270">ao2_ref()</a>'s have been cleaned up.</p>
<dl class="section user"><dt>Shutdown</dt><dd></dd></dl>
<p>Subscriptions have two options for unsubscribing, depending upon the context in which you need to unsubscribe.</p>
<p>If your subscription is owned by a module, and you must unsubscribe from the module_unload() function, then you'll want to use the <a class="el" href="../../dd/d79/stasis_8h.html#a221d05010106dcde0cc2e2b43c1a8b67" title="Cancel a subscription, blocking until the last message is processed. ">stasis_unsubscribe_and_join()</a> function. This will block until the final message has been received on the subscription. Otherwise, there's the danger of invoking the callback function after it has been unloaded.</p>
<p>If your subscription is owned by an object, then your object should have an explicit shutdown() function, which calls <a class="el" href="../../dd/d79/stasis_8h.html#a3498301077e2005383f0d261c471388b" title="Cancel a subscription. ">stasis_unsubscribe()</a>. In your subscription handler, when the <a class="el" href="../../dd/d79/stasis_8h.html#a839350445aaa51cedf31f6daec933ee0" title="Determine whether a message is the final message to be received on a subscription. ">stasis_subscription_final_message()</a> has been received, decrement the refcount on your object. In your object's destructor, you may assert that <a class="el" href="../../dd/d79/stasis_8h.html#a04c69c471e1b836539f280b80b0000de" title="Returns whether subscription has received its final message. ">stasis_subscription_is_done()</a> to validate that the subscription's callback will no longer be invoked.</p>
<p><b>Note:</b> You may be tempted to simply call <a class="el" href="../../dd/d79/stasis_8h.html#a221d05010106dcde0cc2e2b43c1a8b67" title="Cancel a subscription, blocking until the last message is processed. ">stasis_unsubscribe_and_join()</a> from an object's destructor. While code that does this may work most of the time, it's got one big downside. There's a general assumption that object destruction is non-blocking. If you block the destruction waiting for the subscription to complete, there's the danger that the subscription may process a message which will bump the refcount up by one. Then it does whatever it does, decrements the refcount, which then proceeds to re-destroy the object. Now you've got hard to reproduce bugs that only show up under certain loads. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 8 2021 19:47:15 for Asterisk - The Open Source Telephony Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
