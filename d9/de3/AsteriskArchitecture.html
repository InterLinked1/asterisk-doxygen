<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Asterisk - The Open Source Telephony Project: Asterisk Architecture Overview</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Asterisk - The Open Source Telephony Project
   &#160;<span id="projectnumber">18.5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Asterisk Architecture Overview </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Russell Bryant <a href="#" onclick="location.href='mai'+'lto:'+'rus'+'se'+'ll@'+'di'+'giu'+'m.'+'com'; return false;">russe<span style="display: none;">.nosp@m.</span>ll@d<span style="display: none;">.nosp@m.</span>igium<span style="display: none;">.nosp@m.</span>.com</a></dd></dl>
<hr/>
<h1><a class="anchor" id="ArchTOC"></a>
Table of Contents</h1>
<ol type="1">
<li><a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchIntro">Introduction</a></li>
<li><a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchLayout">Modular Architecture</a></li>
<li><a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchInterfaces">Abstract Interface types</a><ol type="a">
<li><a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchInterfaceCodec">Codec Interpreter</a></li>
<li><a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchInterfaceFormat">File Format Handler</a></li>
<li><a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchInterfaceAPIs">C API Providers</a></li>
<li><a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchInterfaceAMI">Manager Interface (AMI) Actions</a></li>
<li><a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchInterfaceChannelDrivers">Channel Drivers</a></li>
<li><a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchInterfaceBridge">Bridging Technologies</a></li>
<li><a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchInterfaceCDR">Call Detail Record (CDR) Handlers</a></li>
<li><a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchInterfaceCEL">Call Event Logging (CEL) Handlers</a></li>
<li><a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchInterfaceDialplanApps">Dialplan Applications</a></li>
<li><a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchInterfaceDialplanFuncs">Dialplan Functions</a></li>
<li><a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchInterfaceRTP">RTP Engines</a></li>
<li><a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchInterfaceTiming">Timing Interfaces</a></li>
</ol>
</li>
<li><a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchThreadingModel">Asterisk Threading Model</a><ol type="a">
<li><a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchChannelThreads">Channel Threads</a></li>
<li><a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchMonitorThreads">Network Monitor Threads</a></li>
<li><a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchServiceThreads">Service Connection Threads</a></li>
<li><a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchOtherThreads">Other Threads</a></li>
</ol>
</li>
<li><a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchConcepts">Other Architecture Concepts</a><ol type="a">
<li><a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchConceptBridging">Channel Bridging</a></li>
</ol>
</li>
<li><a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchCodeFlows">Code Flow Examples</a><ol type="a">
<li><a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchCodeFlowPlayback">SIP Call to File Playback</a></li>
<li><a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchCodeFlowBridge">SIP to IAX2 Bridged Call</a></li>
</ol>
</li>
<li><a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchDataStructures">Asterisk Data Structures</a><ol type="a">
<li><a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchAstobj2">Astobj2</a></li>
<li><a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchLinkedLists">Linked Lists</a></li>
<li><a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchDLinkedLists">Doubly Linked Lists</a></li>
<li><a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchHeap">Heap</a></li>
</ol>
</li>
<li><a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchDebugging">Asterisk Debugging Tools</a><ol type="a">
<li><a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchThreadDebugging">Thread Debugging</a></li>
<li><a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchMemoryDebugging">Memory debugging</a></li>
</ol>
</li>
</ol>
<hr/>
<h1><a class="anchor" id="ArchIntro"></a>
Introduction</h1>
<p>This section of the documentation includes an overview of the Asterisk architecture from a developer's point of view. For detailed API discussion, see the documentation associated with public API header files. This documentation assumes some knowledge of what Asterisk is and how to use it.</p>
<p>The intent behind this documentation is to start looking at Asterisk from a high level and progressively dig deeper into the details. It begins with talking about the different types of components that make up Asterisk and eventually will go through interactions between these components in different use cases.</p>
<p>Throughout this documentation, many links are also provided as references to more detailed information on related APIs, as well as the related source code to what is being discussed.</p>
<p>Feedback and contributions to this documentation are very welcome. Please send your comments to the asterisk-dev mailing list on <a href="http://lists.digium.com/">http://lists.digium.com/</a>.</p>
<p>Thank you, and enjoy Asterisk!</p>
<h1><a class="anchor" id="ArchLayout"></a>
Modular Architecture</h1>
<p>Asterisk is a highly modularized application. There is a core application that is built from the source in the <code>main/</code> directory. However, it is not very useful by itself.</p>
<p>There are many modules that are loaded at runtime. Asterisk modules have names that give an indication as to what functionality they provide, but the name is not special in any technical sense. When Asterisk loads a module, the module registers the functionality that it provides with the Asterisk core.</p>
<ol type="1">
<li>Asterisk starts</li>
<li>Asterisk loads modules</li>
<li>Modules say "Hey Asterisk!  I am a module.  I can provide functionality X, Y,
    and Z.  Let me know when you'd like to use my functionality!"</li>
</ol>
<h1><a class="anchor" id="ArchInterfaces"></a>
Abstract Interface types</h1>
<p>There are many types of interfaces that modules can implement and register their implementations of with the Asterisk core. Any module is allowed to register as many of these different interfaces as they would like. Generally, related functionality is grouped into a single module.</p>
<p>In this section, the types of interfaces are discussed. Later, there will be discussions about how different components interact in various scenarios.</p>
<h2><a class="anchor" id="ArchInterfaceCodec"></a>
Codec Interpreter</h2>
<p>An implementation of the codec interpreter interface provides the ability to convert between two codecs. Asterisk currently only has the ability to translate between audio codecs.</p>
<p>These modules have no knowledge about phone calls or anything else about why they are being asked to convert audio. They just get audio samples as input in their specified input format, and are expected to provide audio in the specified output format.</p>
<p>It is possible to have multiple paths to get from codec A to codec B once many codec implementations are registered. After modules have been loaded, Asterisk builds a translation table with measurements of the performance of each codec translator so that it can always find the best path to get from A to B.</p>
<p>Codec modules typically live in the <code>codecs/</code> directory in the source tree.</p>
<p>For a list of codec interpreter implementations, see <a class="el" href="../../d8/d19/group__codecs.html">Module: Codecs</a>.</p>
<p>For additional information on the codec interpreter API, see the interface definition in <code><a class="el" href="../../db/d39/translate_8h.html" title="Support for translation of data formats. translate.c. ">include/asterisk/translate.h</a></code>.</p>
<p>For core implementation details related to the codec interpreter API, see <code>main/translate.c</code>.</p>
<h2><a class="anchor" id="ArchInterfaceFormat"></a>
File Format Handler</h2>
<p>An implementation of the file format handler interface provides Asterisk the ability to read and optionally write files. File format handlers may provide access to audio, video, or image files.</p>
<p>The interface for a file format handler is rather primitive. A module simply tells the Asterisk core that it can handle files with a given extension, for example, ".wav". It also says that after reading the file, it will provide audio in the form of codec X. If a file format handler provides the ability to write out files, it also must specify what codec the audio should be in before provided to the file format handler.</p>
<p>File format modules typically live in the <code>formats/</code> directory in the source tree.</p>
<p>For a list of file format handler implementations, see <a class="el" href="../../d8/d46/group__formats.html">Module: Media File Formats</a>.</p>
<p>For additional information on the file format handler API, see the interface definition in <code><a class="el" href="../../d2/d4d/file_8h.html" title="Generic File Format Support. Should be included by clients of the file handling routines. File service providers should instead include mod_format.h. ">include/asterisk/file.h</a></code>.</p>
<p>For core implementation details related to the file format API, see <code>main/file.c</code>.</p>
<h2><a class="anchor" id="ArchInterfaceAPIs"></a>
C API Providers</h2>
<p>There are some C APIs in Asterisk that are optional. Core APIs are built into the main application and are always available. Optional C APIs are provided by a module and are only available for use when the module is loaded. Some of these API providers also contain their own interfaces that other modules can implement and register.</p>
<p>Modules that provide a C API typically live in the <code>res/</code> directory in the source tree.</p>
<p>Some examples of modules that provide C APIs (potentially among other things) are:</p><ul>
<li>res_musiconhold.c</li>
<li>res_calendar.c<ul>
<li>provides a calendar technology interface.</li>
</ul>
</li>
<li>res_odbc.c</li>
<li>res_ael_share.c</li>
<li>res_crypto.c</li>
<li>res_curl.c</li>
<li>res_xmpp.c</li>
<li>res_monitor.c</li>
<li>res_smdi.c</li>
<li>res_speech.c<ul>
<li>provides a speech recognition engine interface.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="ArchInterfaceAMI"></a>
Manager Interface (AMI) Actions</h2>
<p>The Asterisk manager interface is a socket interface for monitoring and control of Asterisk. It is a core feature built in to the main application. However, modules can register actions that may be requested by clients.</p>
<p>Modules that register manager actions typically do so as auxiliary functionality to complement whatever main functionality it provides. For example, a module that provides call conferencing services may have a manager action that will return the list of participants in a conference.</p>
<h2><a class="anchor" id="ArchInterfaceCLI"></a>
CLI Commands</h2>
<p>The Asterisk CLI is a feature implemented in the main application. Modules may register additional CLI commands.</p>
<h2><a class="anchor" id="ArchInterfaceChannelDrivers"></a>
Channel Drivers</h2>
<p>The Asterisk channel driver interface is the most complex and most important interface available. The Asterisk channel API provides the telephony protocol abstraction which allows all other Asterisk features to work independently of the telephony protocol in use.</p>
<p>The specific interface that channel drivers implement is the <a class="el" href="../../d4/d85/structast__channel__tech.html" title="Structure to describe a channel &quot;technology&quot;, ie a channel driver See for examples: ...">ast_channel_tech</a> interface. A channel driver must implement functions that perform various call signaling tasks. For example, they must implement a method for initiating a call and hanging up a call. The <a class="el" href="../../df/d3c/structast__channel.html" title="Main Channel structure associated with a channel. ">ast_channel</a> data structure is the abstract channel data structure. Each <a class="el" href="../../df/d3c/structast__channel.html" title="Main Channel structure associated with a channel. ">ast_channel</a> instance has an associated <a class="el" href="../../d4/d85/structast__channel__tech.html" title="Structure to describe a channel &quot;technology&quot;, ie a channel driver See for examples: ...">ast_channel_tech</a> which identifies the channel type. An <a class="el" href="../../df/d3c/structast__channel.html" title="Main Channel structure associated with a channel. ">ast_channel</a> instance represents one leg of a call (a connection between Asterisk and an endpoint).</p>
<p>Channel drivers typically live in the <code>channels/</code> directory in the source tree.</p>
<p>For a list of channel driver implementations, see <a class="el" href="../../d6/df4/group__channel__drivers.html">Module: Asterisk Channel Drivers</a>.</p>
<p>For additional information on the channel API, see <code><a class="el" href="../../d5/d7b/channel_8h.html" title="General Asterisk PBX channel definitions. ">include/asterisk/channel.h</a></code>.</p>
<p>For additional implementation details regarding the core <a class="el" href="../../df/d3c/structast__channel.html" title="Main Channel structure associated with a channel. ">ast_channel</a> API, see <code>main/channel.c</code>.</p>
<h2><a class="anchor" id="ArchInterfaceBridge"></a>
Bridging Technologies</h2>
<p>Bridging is the operation which connects two or more channels together. A simple two channel bridge is a normal A to B phone call, while a multi-party bridge would be something like a 3-way call or a full conference call.</p>
<p>The bridging API allows modules to register bridging technologies. An implementation of a bridging technology knows how to take two (or optionally more) channels and connect them together. Exactly how this happens is up to the implementation.</p>
<p>This interface is used such that the code that needs to pass audio between channels doesn't need to know how it is done. Underneath, the conferencing may be done in the kernel (via DAHDI), via software methods inside of Asterisk, or could be done in hardware in the future if someone implemented a module to do so.</p>
<p>At the time of this writing, the bridging API is still relatively new, so it is not used everywhere that bridging operations are performed. The ConfBridge dialplan application is a new conferencing application which has been implemented on top of this bridging API.</p>
<p>Bridging technology modules typically live in the <code>bridges/</code> directory in the source tree.</p>
<p>For a list of bridge technology implementations, see <a class="el" href="../../dir_248c5494cbf50d375c6b51a2b292aa12.html">bridges</a>.</p>
<p>For additional information on the bridging API, see </p><ul>
<li><code><a class="el" href="../../d4/d56/bridge_8h.html" title="Bridging API. ">include/asterisk/bridge.h</a></code> </li>
<li><code><a class="el" href="../../d0/d3b/bridge__technology_8h.html" title="Channel Bridging API. ">include/asterisk/bridge_technology.h</a></code> </li>
<li><code><a class="el" href="../../de/d41/bridge__channel_8h.html">include/asterisk/bridge_channel.h</a></code> </li>
<li><code><a class="el" href="../../dc/d7a/bridge__features_8h.html" title="Channel Bridging API. ">include/asterisk/bridge_features.h</a></code> </li>
<li><code><a class="el" href="../../d8/d85/bridge__after_8h.html" title="After Bridge Execution API. ">include/asterisk/bridge_after.h</a></code></li>
</ul>
<p>For additional implementation details regarding the core bridging API, see <code>main/bridge.c</code> and <code>main/bridge_channel.c</code>.</p>
<h2><a class="anchor" id="ArchInterfaceCDR"></a>
Call Detail Record (CDR) Handlers</h2>
<p>The Asterisk core implements functionality for keeping records of calls. These records are built while calls are processed and live in data structures. At the end of the call, these data structures are released. Before the records are thrown away, they are passed in to all of the registered CDR handlers. These handlers may write out the records to a file, post them to a database, etc.</p>
<p>CDR modules typically live in the <code>cdr</code> directory in the source tree.</p>
<p>For a list of CDR handlers, see <a class="el" href="../../d7/d32/group__cdr__drivers.html">Module: CDR Drivers</a>.</p>
<p>For additional information on the CDR API, see <code><a class="el" href="../../dc/d07/cdr_8h.html" title="Call Detail Record API. ">include/asterisk/cdr.h</a></code>.</p>
<p>For additional implementation details regarding CDR handling, see <code>main/cdr.c</code>.</p>
<h2><a class="anchor" id="ArchInterfaceCEL"></a>
Call Event Logging (CEL) Handlers</h2>
<p>The Asterisk core includes a generic event system that allows Asterisk components to report events that can be subscribed to by other parts of the system. One of the things built on this event system is Call Event Logging (CEL).</p>
<p>CEL is similar to CDR in that they are both for tracking call history. While CDR records are typically have a one record to one call relationship, CEL events are many events to one call. The CEL modules look very similar to CDR modules.</p>
<p>CEL modules typically live in the <code>cel/</code> directory in the source tree.</p>
<p>For a list of CEL handlers, see cel_drivers.</p>
<p>For additional information about the CEL API, see <code><a class="el" href="../../dc/dfb/cel_8h.html" title="Call Event Logging API. ">include/asterisk/cel.h</a></code>.</p>
<p>For additional implementation details for the CEL API, see <code>main/cel.c</code>.</p>
<h2><a class="anchor" id="ArchInterfaceDialplanApps"></a>
Dialplan Applications</h2>
<p>Dialplan applications implement features that interact with calls that can be executed from the Asterisk dialplan. For example, in <code>extensions.conf</code>:</p>
<p><code>exten =&gt; 123,1,NoOp()</code></p>
<p>In this case, NoOp is the application. Of course, NoOp doesn't actually do anything.</p>
<p>These applications use a number of APIs available in Asterisk to interact with the channel. One of the most important tasks of an application is to continuously read audio from the channel, and also write audio back to the channel. The details of how this is done is usually hidden behind an API call used to play a file or wait for digits to be pressed by a caller.</p>
<p>In addition to interacting with the channel that originally executed the application, dialplan applications sometimes also create additional outbound channels. For example, the Dial() application creates an outbound channel and bridges it to the inbound channel. Further discussion about the functionality of applications will be discussed in detailed use cases.</p>
<p>Dialplan applications are typically found in the <code>apps/</code> directory in the source tree.</p>
<p>For a list of dialplan applications, see <a class="el" href="../../d9/dc9/group__applications.html">Dial plan applications</a>.</p>
<p>For details on the API used to register an application with the Asterisk core, see <code><a class="el" href="../../db/de0/pbx_8h.html" title="Core PBX routines and definitions. ">include/asterisk/pbx.h</a></code>.</p>
<h2><a class="anchor" id="ArchInterfaceDialplanFuncs"></a>
Dialplan Functions</h2>
<p>As the name suggests, dialplan functions, like dialplan applications, are primarily used from the Asterisk dialplan. Functions are used mostly in the same way that variables are used in the dialplan. They provide a read and/or write interface, with optional arguments. While they behave similarly to variables, they storage and retrieval of a value is more complex than a simple variable with a text value.</p>
<p>For example, the <code>CHANNEL()</code> dialplan function allows you to access data on the current channel.</p>
<p><code>exten =&gt; 123,1,NoOp(This channel has the name: ${CHANNEL(name)})</code></p>
<p>Dialplan functions are typically found in the <code>funcs/</code> directory in the source tree.</p>
<p>For a list of dialplan function implementations, see <a class="el" href="../../d5/db0/group__functions.html">Module: Dial plan functions</a>.</p>
<p>For details on the API used to register a dialplan function with the Asterisk core, see <code><a class="el" href="../../db/de0/pbx_8h.html" title="Core PBX routines and definitions. ">include/asterisk/pbx.h</a></code>.</p>
<h2><a class="anchor" id="ArchInterfaceRTP"></a>
RTP Engines</h2>
<p>The Asterisk core provides an API for handling RTP streams. However, the actual handling of these streams is done by modules that implement the RTP engine interface. Implementations of an RTP engine typically live in the <code>res/</code> directory of the source tree, and have a <code>res_rtp_</code> prefix in their name.</p>
<h2><a class="anchor" id="ArchInterfaceTiming"></a>
Timing Interfaces</h2>
<p>The Asterisk core implements an API that can be used by components that need access to timing services. For example, a timer is used to send parts of an audio file at proper intervals when playing back a sound file to a caller. The API relies on timing interface implementations to provide a source for reliable timing.</p>
<p>Timing interface implementations are typically found in the <code>res/</code> subdirectory of the source tree.</p>
<p>For a list of timing interface implementations, see <a class="el" href="../../d3/d62/timing_8c.html#a38607df66c48ce2280bfada876244b00">timing_interfaces</a>.</p>
<p>For additional information on the timing API, see <code><a class="el" href="../../db/d41/timing_8h.html" title="Timing source management. ">include/asterisk/timing.h</a></code>.</p>
<p>For additional implementation details for the timing API, see <code>main/timing.c</code>.</p>
<h1><a class="anchor" id="ArchThreadingModel"></a>
Asterisk Threading Model</h1>
<p>Asterisk is a very heavily multi threaded application. It uses the POSIX threads API to manage threads and related services such as locking. Almost all of the Asterisk code that interacts with pthreads does so by going through a set of wrappers used for debugging and code reduction.</p>
<p>Threads in Asterisk can be classified as one of the following types:</p>
<ul>
<li>Channel threads (sometimes referred to as PBX threads)</li>
<li>Network Monitor threads</li>
<li>Service connection threads</li>
<li>Other threads</li>
</ul>
<h2><a class="anchor" id="ArchChannelThreads"></a>
Channel Threads</h2>
<p>A channel is a fundamental concept in Asterisk. Channels are either inbound or outbound. An inbound channel is created when a call comes in to the Asterisk system. These channels are the ones that execute the Asterisk dialplan. A thread is created for every channel that executes the dialplan. These threads are referred to as a channel thread. They are sometimes also referred to as a PBX thread, since one of the primary tasks of the thread is to execute the Asterisk dialplan for an inbound call.</p>
<p>A channel thread starts out by only being responsible for a single Asterisk channel. However, there are cases where a second channel may also live in a channel thread. When an inbound channel executes an application such as <code>Dial()</code>, an outbound channel is created and bridged to the inbound channel once it answers.</p>
<p>Dialplan applications always execute in the context of a channel thread. Dialplan functions almost always do, as well. However, it is possible to read and write dialplan functions from an asynchronous interface such as the Asterisk CLI or the manager interface (AMI). However, it is still always the channel thread that is the owner of the <a class="el" href="../../df/d3c/structast__channel.html" title="Main Channel structure associated with a channel. ">ast_channel</a> data structure.</p>
<h2><a class="anchor" id="ArchMonitorThreads"></a>
Network Monitor Threads</h2>
<p>Network monitor threads exist in almost every major channel driver in Asterisk. They are responsible for monitoring whatever network they are connected to (whether that is an IP network, the PSTN, etc.) and monitor for incoming calls or other types of incoming requests. They handle the initial connection setup steps such as authentication and dialed number validation. Finally, once the call setup has been completed, the monitor threads will create an instance of an Asterisk channel (<a class="el" href="../../df/d3c/structast__channel.html" title="Main Channel structure associated with a channel. ">ast_channel</a>), and start a channel thread to handle the call for the rest of its lifetime.</p>
<h2><a class="anchor" id="ArchServiceThreads"></a>
Service Connection Threads</h2>
<p>There are a number of TCP based services that use threads, as well. Some examples include SIP and the AMI. In these cases, threads are used to handle each TCP connection.</p>
<p>The Asterisk CLI also operates in a similar manner. However, instead of TCP, the Asterisk CLI operates using connections to a UNIX domain socket.</p>
<h2><a class="anchor" id="ArchOtherThreads"></a>
Other Threads</h2>
<p>There are other miscellaneous threads throughout the system that perform a specific task. For example, the event API (<a class="el" href="../../dd/d20/event_8h.html">include/asterisk/event.h</a>) uses a thread internally (main/event.c) to handle asychronous event dispatching. The devicestate API (<a class="el" href="../../da/da2/devicestate_8h.html" title="Device state management. ">include/asterisk/devicestate.h</a>) uses a thread internally (main/devicestate.c) to asynchronously process device state changes.</p>
<h1><a class="anchor" id="ArchConcepts"></a>
Other Architecture Concepts</h1>
<p>This section covers some other important Asterisk architecture concepts.</p>
<h2><a class="anchor" id="ArchConceptBridging"></a>
Channel Bridging</h2>
<p>As previously mentioned when discussing the bridging technology interface (<a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchInterfaceBridge">Bridging Technologies</a>), bridging is the act of connecting one or more channel together so that they may pass audio between each other. However, it was also mentioned that most of the code in Asterisk that does bridging today does not use this new bridging infrastructure. So, this section discusses the legacy bridging functionality that is used by the <code>Dial()</code> and <code>Queue()</code> applications.</p>
<p>When one of these applications decides it would like to bridge two channels together, it does so by executing the ast_channel_bridge() API call. From there, there are two types of bridges that may occur.</p>
<ol type="1">
<li><b>Generic Bridge:</b> A generic bridge (ast_generic_bridge()) is a bridging method that works regardless of what channel technologies are in use. It passes all audio and signaling through the Asterisk abstract channel and frame interfaces so that they can be communicated between channel drivers of any type. While this is the most flexible, it is also the least efficient bridging method due to the levels of abstraction necessary.</li>
<li><b>Native Bridge:</b> Channel drivers have the option of implementing their own bridging functionality. Specifically, this means to implement the bridge callback in the <a class="el" href="../../d4/d85/structast__channel__tech.html" title="Structure to describe a channel &quot;technology&quot;, ie a channel driver See for examples: ...">ast_channel_tech</a> structure. If two channels of the same type are bridged, a native bridge method is available, and Asterisk does not have a reason to force the call to stay in the core of Asterisk, then the native bridge function will be invoked. This allows channel drivers to take advantage of the fact that the channels are the same type to optimize bridge processing. In the case of a DAHDI channel, this may mean that the channels are bridged natively on hardware. In the case of SIP, this means that Asterisk can direct the audio to flow between the endpoints and only require the signaling to continue to flow through Asterisk.</li>
</ol>
<h1><a class="anchor" id="ArchCodeFlows"></a>
Code Flow Examples</h1>
<p>Now that there has been discussion about the various components that make up Asterisk, this section goes through examples to demonstrate how these components work together to provide useful functionality.</p>
<h2><a class="anchor" id="ArchCodeFlowPlayback"></a>
SIP Call to File Playback</h2>
<p>This example consists of a call that comes in to Asterisk via the SIP protocol. Asterisk accepts this call, plays back a sound file to the caller, and then hangs up.</p>
<p>Example dialplan:</p>
<p><code>exten =&gt; 5551212,1,Answer()</code><br />
 <code>exten =&gt; 5551212,n,Playback(demo-congrats)</code><br />
 <code>exten =&gt; 5551212,n,Hangup()</code><br />
</p>
<ol type="1">
<li><b>Call Setup:</b> An incoming SIP INVITE begins this scenario. It is received by the SIP channel driver (chan_sip.c). Specifically, the monitor thread in chan_sip is responsible for handling this incoming request. Further, the monitor thread is responsible for completing any handshake necessary to complete the call setup process.</li>
<li><b>Accept Call:</b> Once the SIP channel driver has completed the call setup process, it accepts the call and initiates the call handling process in Asterisk. To do so, it must allocate an instance of an abstract channel (<a class="el" href="../../df/d3c/structast__channel.html" title="Main Channel structure associated with a channel. ">ast_channel</a>) using the <a class="el" href="../../d5/d7b/channel_8h.html#a2f18aafad0442206e71033ac6676dbb5" title="Create a channel structure. ">ast_channel_alloc()</a> API call. This instance of an <a class="el" href="../../df/d3c/structast__channel.html" title="Main Channel structure associated with a channel. ">ast_channel</a> will be referred to as a SIP channel. The SIP channel driver will take care of SIP specific channel initialization. Once the channel has been created and initialized, a channel thread is created to handle the call (<a class="el" href="../../db/de0/pbx_8h.html#a9a937fbb3b5f4e68880a9c5714a29ce5" title="Create a new thread and start the PBX. ">ast_pbx_start()</a>).</li>
<li><b>Run the Dialplan:</b>: The main loop that runs in the channel thread is the code responsible for looking for the proper extension and then executing it. This loop lives in <a class="el" href="../../db/de0/pbx_8h.html#a44b6406c9220f7f2b610ac712369f405" title="Execute the PBX in the current thread. ">ast_pbx_run()</a> in main/pbx.c.</li>
<li><b>Answer the Call:</b>: Once the dialplan is being executed, the first application that is executed is <code>Answer()</code>. This application is a built in application that is defined in main/pbx.c. The <code>Answer()</code> application code simply executes the <a class="el" href="../../d5/d7b/channel_8h.html#aec583a3e25358ee552a4f3df53914cd0" title="Answer a channel. ">ast_answer()</a> API call. This API call operates on an <a class="el" href="../../df/d3c/structast__channel.html" title="Main Channel structure associated with a channel. ">ast_channel</a>. It handles generic <a class="el" href="../../df/d3c/structast__channel.html" title="Main Channel structure associated with a channel. ">ast_channel</a> hangup processing, as well as executes the answer callback function defined in the associated <a class="el" href="../../d4/d85/structast__channel__tech.html" title="Structure to describe a channel &quot;technology&quot;, ie a channel driver See for examples: ...">ast_channel_tech</a> for the active channel. In this case, the <a class="el" href="../../d5/dfe/chan__sip_8c.html#aebb490de27494c8e90ad7209f7e1d6d7" title="sip_answer: Answer SIP call , send 200 OK on Invite Part of PBX interface ">sip_answer()</a> function in chan_sip.c will get executed to handle the SIP specific operations required to answer a call.</li>
<li><b>Play the File:</b> The next step of the dialplan says to play back a sound file to the caller. The <code>Playback()</code> application will be executed. The code for this application is in apps/app_playback.c. The code in the application is pretty simple. It does argument handling and uses API calls to play back the file, <a class="el" href="../../d2/d4d/file_8h.html#a67c7e271b4ca70aca6d48fd48d121857" title="Streams a file. ">ast_streamfile()</a>, <a class="el" href="../../d2/d4d/file_8h.html#affc21cb57c6bf72a2cb7ec8a379b2137" title="Waits for a stream to stop or digit to be pressed. ">ast_waitstream()</a>, and <a class="el" href="../../d2/d4d/file_8h.html#a3092bf11d4bba66f646562759608b1bc" title="Stops a stream. ">ast_stopstream()</a>, which set up file playback, wait for the file to finish playing, and then free up resources. Some of the important operations of these API calls are described in steps here:<ol type="a">
<li><b>Open a File:</b> The file format API is responsible for opening the sound file. It will start by looking for a file that is encoded in the same format that the channel is expecting to receive audio in. If that is not possible, it will find another type of file that can be translated into the codec that the channel is expecting. Once a file is found, the appropriate file format interface is invoked to handle reading the file and turning it into internal Asterisk audio frames.</li>
<li><b>Set up Translation:</b> If the encoding of the audio data in the file does not match what the channel is expecting, the file API will use the codec translation API to set up a translation path. The translate API will invoke the appropriate codec translation interface(s) to get from the source to the destination format in the most efficient way available.</li>
<li><b>Feed Audio to the Caller:</b> The file API will invoke the timer API to know how to send out audio frames from the file in proper intervals. At the same time, Asterisk must also continuously service the incoming audio from the channel since it will continue to arrive in real time. However, in this scenario, it will just get thrown away.</li>
</ol>
</li>
<li><b>Hang up the Call:</b> Once the <code>Playback()</code> application has finished, the dialplan execution loop continues to the next step in the dialplan, which is <code>Hangup()</code>. This operates in a very similar manner to <code>Answer()</code> in that it handles channel type agnostic hangup handling, and then calls down into the SIP channel interface to handle SIP specific hangup processing. At this point, even if there were more steps in the dialplan, processing would stop since the channel has been hung up. The channel thread will exit the dialplan processing loop and destroy the <a class="el" href="../../df/d3c/structast__channel.html" title="Main Channel structure associated with a channel. ">ast_channel</a> data structure.</li>
</ol>
<h2><a class="anchor" id="ArchCodeFlowBridge"></a>
SIP to IAX2 Bridged Call</h2>
<p>This example consists of a call that comes in to Asterisk via the SIP protocol. Asterisk then makes an outbound call via the IAX2 protocol. When the far end over IAX2 answers, the call is bridged.</p>
<p>Example dialplan:</p>
<p><code>exten =&gt; 5551212,n,Dial(IAX2/mypeer)</code><br />
</p>
<ol type="1">
<li><b>Call Setup:</b> An incoming SIP INVITE begins this scenario. It is received by the SIP channel driver (chan_sip.c). Specifically, the monitor thread in chan_sip is responsible for handling this incoming request. Further, the monitor thread is responsible for completing any handshake necessary to complete the call setup process.</li>
<li><b>Accept Call:</b> Once the SIP channel driver has completed the call setup process, it accepts the call and initiates the call handling process in Asterisk. To do so, it must allocate an instance of an abstract channel (<a class="el" href="../../df/d3c/structast__channel.html" title="Main Channel structure associated with a channel. ">ast_channel</a>) using the <a class="el" href="../../d5/d7b/channel_8h.html#a2f18aafad0442206e71033ac6676dbb5" title="Create a channel structure. ">ast_channel_alloc()</a> API call. This instance of an <a class="el" href="../../df/d3c/structast__channel.html" title="Main Channel structure associated with a channel. ">ast_channel</a> will be referred to as a SIP channel. The SIP channel driver will take care of SIP specific channel initialization. Once the channel has been created and initialized, a channel thread is created to handle the call (<a class="el" href="../../db/de0/pbx_8h.html#a9a937fbb3b5f4e68880a9c5714a29ce5" title="Create a new thread and start the PBX. ">ast_pbx_start()</a>).</li>
<li><b>Run the Dialplan:</b>: The main loop that runs in the channel thread is the code responsible for looking for the proper extension and then executing it. This loop lives in <a class="el" href="../../db/de0/pbx_8h.html#a44b6406c9220f7f2b610ac712369f405" title="Execute the PBX in the current thread. ">ast_pbx_run()</a> in main/pbx.c.</li>
<li><b>Execute Dial()</b>: The only step in this dialplan is to execute the <code>Dial()</code> application.<ol type="a">
<li><b>Create an Outbound Channel:</b> The <code>Dial()</code> application needs to create an outbound <a class="el" href="../../df/d3c/structast__channel.html" title="Main Channel structure associated with a channel. ">ast_channel</a>. It does this by first using the <a class="el" href="../../d5/d7b/channel_8h.html#a39fc055500e09810d0afd0bff87407c5" title="Requests a channel. ">ast_request()</a> API call to request a channel called <code>IAX2/mypeer</code>. This API call is a part of the core channel API (<a class="el" href="../../d5/d7b/channel_8h.html" title="General Asterisk PBX channel definitions. ">include/asterisk/channel.h</a>). It will find a channel driver of type <code>IAX2</code> and then execute the request callback in the appropriate <a class="el" href="../../d4/d85/structast__channel__tech.html" title="Structure to describe a channel &quot;technology&quot;, ie a channel driver See for examples: ...">ast_channel_tech</a> interface. In this case, it is <a class="el" href="../../d5/dff/chan__iax2_8c.html#acd1dd09fa6e92a25cdf7b33eb683f961">iax2_request()</a> in channels/chan_iax2.c. This asks the IAX2 channel driver to allocate an <a class="el" href="../../df/d3c/structast__channel.html" title="Main Channel structure associated with a channel. ">ast_channel</a> of type IAX2 and initialize it. The <code>Dial()</code> application will then execute the <a class="el" href="../../d5/d7b/channel_8h.html#a1b732eb4ed203140b1a3aae9e7dec2c1" title="Make a call. ">ast_call()</a> API call for this new <a class="el" href="../../df/d3c/structast__channel.html" title="Main Channel structure associated with a channel. ">ast_channel</a>. This will call into the call callback of the <a class="el" href="../../d4/d85/structast__channel__tech.html" title="Structure to describe a channel &quot;technology&quot;, ie a channel driver See for examples: ...">ast_channel_tech</a>, <a class="el" href="../../d5/dff/chan__iax2_8c.html#a44896c6d1b0132883faea9396a72bb4e">iax2_call()</a>, which requests that the IAX2 channel driver initiate the outbound call.</li>
<li><b>Wait for Answer:</b> At this point, the Dial() application waits for the outbound channel to answer the call. While it does this, it must continue to service the incoming audio on both the inbound and outbound channels. The loop that does this is very similar to every other channel servicing loop in Asterisk. The core features of a channel servicing loop include <a class="el" href="../../d5/d7b/channel_8h.html#a60e0bcaed001e8d5ed1ba0eb2644b3cc" title="Wait for input on a channel. ">ast_waitfor()</a> to wait for frames on a channel, and then <a class="el" href="../../d5/d7b/channel_8h.html#a7ef6737309dc9e8b6c4a7cb4800638b1" title="Reads a frame. ">ast_read()</a> on a channel once frames are available.</li>
<li><b>Handle Answer:</b> Once the far end answers the call, the <code>Dial()</code> application will communicate this back to the inbound SIP channel. It does this by calling the <a class="el" href="../../d5/d7b/channel_8h.html#aec583a3e25358ee552a4f3df53914cd0" title="Answer a channel. ">ast_answer()</a> core channel API call.</li>
<li><b>Make Channels Compatible:</b> Before the two ends of the call can be connected, Asterisk must make them compatible to talk to each other. Specifically, the two channels may be sending and expecting to receive audio in a different format than the other channel. The API call <a class="el" href="../../d5/d7b/channel_8h.html#a4aff0f5358bdc107a92320b4c4631834" title="Make the frame formats of two channels compatible. ">ast_channel_make_compatible()</a> sets up translation paths for each channel by instantiating codec translators as necessary.</li>
<li><b>Bridge the Channels:</b> Now that both the inbound and outbound channels are fully established, they can be connected together. This connection between the two channels so that they can pass audio and signaling back and forth is referred to as a bridge. The API call that handles the bridge is ast_channel_bridge(). In this case, the main loop of the bridge is a generic bridge, ast_generic_bridge(), which is the type of bridge that works regardless of the two channel types. A generic bridge will almost always be used if the two channels are not of the same type. The core functionality of a bridge loop is <a class="el" href="../../d5/d7b/channel_8h.html#a60e0bcaed001e8d5ed1ba0eb2644b3cc" title="Wait for input on a channel. ">ast_waitfor()</a> on both channels. Then, when frames arrive on a channel, they are read using <a class="el" href="../../d5/d7b/channel_8h.html#a7ef6737309dc9e8b6c4a7cb4800638b1" title="Reads a frame. ">ast_read()</a>. After reading a frame, they are written to the other channel using <a class="el" href="../../d5/d7b/channel_8h.html#a79c413d51b7135404d5cacf811649a61" title="Write a frame to a channel This function writes the given frame to the indicated channel. ">ast_write()</a>.</li>
<li><b>Breaking the Bridge</b>: This bridge will continue until some event occurs that causes the bridge to be broken, and control to be returned back down to the <code>Dial()</code> application. For example, if one side of the call hangs up, the bridge will stop.</li>
</ol>
</li>
<li><b>Hanging Up:</b>: After the bridge stops, control will return to the <code>Dial()</code> application. The application owns the outbound channel since that is where it was created. So, the outbound IAX2 channel will be destroyed before <code>Dial()</code> is complete. Destroying the channel is done by using the <a class="el" href="../../d5/d7b/channel_8h.html#a29557c4823f5e9c02519a01daf6a289c" title="Hang up a channel. ">ast_hangup()</a> API call. The application will return back to the dialplan processing loop. From there, the loop will see that there is nothing else to execute, so it will hangup on the inbound channel as well using the <a class="el" href="../../d5/d7b/channel_8h.html#a29557c4823f5e9c02519a01daf6a289c" title="Hang up a channel. ">ast_hangup()</a> function. <a class="el" href="../../d5/d7b/channel_8h.html#a29557c4823f5e9c02519a01daf6a289c" title="Hang up a channel. ">ast_hangup()</a> performs a number of channel type independent hangup tasks, but also executes the hangup callback of <a class="el" href="../../d4/d85/structast__channel__tech.html" title="Structure to describe a channel &quot;technology&quot;, ie a channel driver See for examples: ...">ast_channel_tech</a> (<a class="el" href="../../d5/dfe/chan__sip_8c.html#a4b6d430f9be239d961c8d09276490edc" title="sip_hangup: Hangup SIP call Part of PBX interface, called from ast_hangup ">sip_hangup()</a>). Finally, the channel thread exits.</li>
</ol>
<h1><a class="anchor" id="ArchDataStructures"></a>
Asterisk Data Structures</h1>
<p>Asterisk provides generic implementations of a number of data structures.</p>
<h2><a class="anchor" id="ArchAstobj2"></a>
Astobj2</h2>
<p>Astobj2 stands for the Asterisk Object model, version 2. The API is defined in <a class="el" href="../../d5/da5/astobj2_8h.html">include/asterisk/astobj2.h</a>. Some internal implementation details for <a class="el" href="../../d3/dfb/structastobj2.html">astobj2</a> can be found in main/astobj2.c. There is a version 1, and it still exists in the source tree. However, it is considered deprecated.</p>
<p>Astobj2 provides reference counted object handling. It also provides a container interface for <a class="el" href="../../d3/dfb/structastobj2.html">astobj2</a> objects. The container provided is a hash table.</p>
<p>See the <a class="el" href="../../d3/dfb/structastobj2.html">astobj2</a> API for more details about how to use it. Examples can be found all over the code base.</p>
<h2><a class="anchor" id="ArchLinkedLists"></a>
Linked Lists</h2>
<p>Asterisk provides a set of macros for handling linked lists. They are defined in <a class="el" href="../../df/d90/linkedlists_8h.html" title="A set of macros to manage forward-linked lists. ">include/asterisk/linkedlists.h</a>.</p>
<h2><a class="anchor" id="ArchDLinkedLists"></a>
Doubly Linked Lists</h2>
<p>Asterisk provides a set of macros for handling doubly linked lists, as well. They are defined in <a class="el" href="../../d0/d43/dlinkedlists_8h.html" title="A set of macros to manage doubly-linked lists. ">include/asterisk/dlinkedlists.h</a>.</p>
<h2><a class="anchor" id="ArchHeap"></a>
Heap</h2>
<p>Asterisk provides an implementation of the max heap data structure. The API is defined in <a class="el" href="../../da/ddb/heap_8h.html" title="Max Heap data structure. ">include/asterisk/heap.h</a>. The internal implementation details can be found in main/heap.c.</p>
<h1><a class="anchor" id="ArchDebugging"></a>
Asterisk Debugging Tools</h1>
<p>Asterisk includes a number of built in debugging tools to help in diagnosing common types of problems.</p>
<h2><a class="anchor" id="ArchThreadDebugging"></a>
Thread Debugging</h2>
<p>Asterisk keeps track of a list of all active threads on the system. A list of threads can be viewed from the Asterisk CLI by running the command <code>core show threads</code>.</p>
<p>Asterisk has a compile time option called <code>DEBUG_THREADS</code>. When this is on, the pthread wrapper API in Asterisk keeps track of additional information related to threads and locks to aid in debugging. In addition to just keeping a list of threads, Asterisk also maintains information about every lock that is currently held by any thread on the system. It also knows when a thread is blocking while attempting to acquire a lock. All of this information is extremely useful when debugging a deadlock. This data can be acquired from the Asterisk CLI by running the <code>core show locks</code> CLI command.</p>
<p>The definitions of these wrappers can be found in <code><a class="el" href="../../dd/d42/lock_8h.html" title="Asterisk locking-related definitions: ">include/asterisk/lock.h</a></code> and <code><a class="el" href="../../d5/d60/utils_8h.html" title="Utility functions. ">include/asterisk/utils.h</a></code>. Most of the implementation details can be found in <code>main/utils.c</code>.</p>
<h2><a class="anchor" id="ArchMemoryDebugging"></a>
Memory debugging</h2>
<p>Dynamic memory management in Asterisk is handled through a number of wrappers defined in <code><a class="el" href="../../d5/d60/utils_8h.html" title="Utility functions. ">include/asterisk/utils.h</a></code>. By default, all of these wrappers use the standard C library <a class="el" href="../../d9/d02/gsm__create_8c.html#ab7e36af3707843f77cc5b4e831c2fa6d">malloc()</a>, <a class="el" href="../../da/dfd/gsm__destroy_8c.html#aafde19f7d36ca163a143579c1b125b6d">free()</a>, etc. functions. However, if Asterisk is compiled with the MALLOC_DEBUG option enabled, additional memory debugging is included.</p>
<p>The Asterisk memory debugging system provides the following features:</p>
<ul>
<li>Track all current allocations including their size and the file, function, and line number where they were initiated.</li>
<li>When releasing memory, do some basic fence checking to see if anything wrote into the few bytes immediately surrounding an allocation.</li>
<li>Get notified when attempting to free invalid memory.</li>
</ul>
<p>A number of CLI commands are provided to access data on the current set of memory allocations. Those are:</p>
<ul>
<li><code>memory show summary</code></li>
<li><code>memory show allocations</code></li>
</ul>
<p>The implementation of this memory debugging system can be found in <code>main/astmm.c</code>.</p>
<hr/>
<p> Return to the <a class="el" href="../../d9/de3/AsteriskArchitecture.html#ArchTOC">Table of Contents</a> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 8 2021 19:47:14 for Asterisk - The Open Source Telephony Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
