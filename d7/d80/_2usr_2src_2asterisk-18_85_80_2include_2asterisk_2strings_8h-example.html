<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Asterisk - The Open Source Telephony Project: /usr/src/asterisk-18.5.0/include/asterisk/strings.h</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Asterisk - The Open Source Telephony Project
   &#160;<span id="projectnumber">18.5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">/usr/src/asterisk-18.5.0/include/asterisk/strings.h</div>  </div>
</div><!--header-->
<div class="contents">
<p>Provides a temporary <a class="el" href="../../dd/da2/structast__str.html" title="The descriptor of a dynamic string XXX storage will be optimized later if needed We use the ts field ...">ast_str</a> and returns a copy of its buffer </p><dl class="section since"><dt>Since</dt><dd>16.12 </dd>
<dd>
17.6 </dd>
<dd>
18.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init_len</td><td>The initial length of the temporary <a class="el" href="../../dd/da2/structast__str.html" title="The descriptor of a dynamic string XXX storage will be optimized later if needed We use the ts field ...">ast_str</a> needed. </td></tr>
    <tr><td class="paramname">__expr</td><td>An expression that needs the temporary <a class="el" href="../../dd/da2/structast__str.html" title="The descriptor of a dynamic string XXX storage will be optimized later if needed We use the ts field ...">ast_str</a> and returns a char *.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of __expr's return buffer allocated on the stack.</dd></dl>
<p>There are a few query functions scattered around that need an <a class="el" href="../../dd/da2/structast__str.html" title="The descriptor of a dynamic string XXX storage will be optimized later if needed We use the ts field ...">ast_str</a> in which to assemble the results but it's not always convenient to create an <a class="el" href="../../dd/da2/structast__str.html" title="The descriptor of a dynamic string XXX storage will be optimized later if needed We use the ts field ...">ast_str</a> and ensure it's freed just to print a log message. For example...</p>
<p>struct <a class="el" href="../../dd/da2/structast__str.html" title="The descriptor of a dynamic string XXX storage will be optimized later if needed We use the ts field ...">ast_str</a> *temp = <a class="el" href="../../d6/d90/strings_8h.html#a9c34c6c6b8daaba24c0406270f3cf697" title="Create a malloc&#39;ed dynamic length string. ">ast_str_create(128)</a>; ast_log(LOG_INFO, "Format caps: %s\n", ast_format_cap_get_names(caps, &amp;temp)); <a class="el" href="../../d7/de0/backtrace_8c.html#a009087abea3c00645ea08d90d17478ea">ast_free(temp)</a>;</p>
<p>That's not bad if you only have to do it once but some of our code that deals with streams and codecs is pretty complex and good instrumentation is essential. The aim of this function is to make that easier.</p>
<p>With this macro, the above code can be simplified as follows...</p>
<p>ast_log(LOG_INFO, "Format caps: %s\n", <a class="el" href="../../d6/d90/strings_8h.html#a68ab38eef5d5958cae536ba7589093cc">ast_str_tmp(128, ast_format_cap_get_names(caps, &amp;STR_TMP))</a>;</p>
<p>STR_TMP will always be a reference to the temporary <a class="el" href="../../dd/da2/structast__str.html" title="The descriptor of a dynamic string XXX storage will be optimized later if needed We use the ts field ...">ast_str</a> created by the macro. Its scope is limited by the macro so you can use it multiple times without conflict.</p>
<div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Asterisk -- An open source telephony toolkit.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 1999 - 2006, Digium, Inc.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Mark Spencer &lt;markster@digium.com&gt;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * See http://www.asterisk.org for more information about</span></div><div class="line"><span class="comment"> * the Asterisk project. Please do not directly contact</span></div><div class="line"><span class="comment"> * any of the maintainers of this project for assistance;</span></div><div class="line"><span class="comment"> * the project provides a web site, mailing lists and IRC</span></div><div class="line"><span class="comment"> * channels for your use.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This program is free software, distributed under the terms of</span></div><div class="line"><span class="comment"> * the GNU General Public License Version 2. See the LICENSE file</span></div><div class="line"><span class="comment"> * at the top of the source tree.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*! \file</span></div><div class="line"><span class="comment"> * \brief String manipulation functions</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifndef _ASTERISK_STRINGS_H</span></div><div class="line"><span class="preprocessor">#define _ASTERISK_STRINGS_H</span></div><div class="line"></div><div class="line"><span class="comment">/* #define DEBUG_OPAQUE */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;ctype.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;limits.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d5/d60/utils_8h.html">asterisk/utils.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../dc/d7d/threadstorage_8h.html">asterisk/threadstorage.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d5/da5/astobj2_8h.html">asterisk/astobj2.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#if defined(DEBUG_OPAQUE)</span></div><div class="line"><span class="preprocessor">#define __AST_STR_USED used2</span></div><div class="line"><span class="preprocessor">#define __AST_STR_LEN len2</span></div><div class="line"><span class="preprocessor">#define __AST_STR_STR str2</span></div><div class="line"><span class="preprocessor">#define __AST_STR_TS ts2</span></div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="preprocessor">#define __AST_STR_USED used</span></div><div class="line"><span class="preprocessor">#define __AST_STR_LEN len</span></div><div class="line"><span class="preprocessor">#define __AST_STR_STR str</span></div><div class="line"><span class="preprocessor">#define __AST_STR_TS ts</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="comment">/* You may see casts in this header that may seem useless but they ensure this file is C++ clean */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define AS_OR(a,b)   (a &amp;&amp; ast_str_strlen(a)) ? ast_str_buffer(a) : (b)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef AST_DEVMODE</span></div><div class="line"><span class="preprocessor">#define ast_strlen_zero(foo)  _ast_strlen_zero(foo, __FILE__, __PRETTY_FUNCTION__, __LINE__)</span></div><div class="line"><span class="keyword">static</span> <a name="a0"></a><a class="code" href="../../d4/dd1/compiler_8h.html#ae8c57c7218a376f10cbdf0e50f1189ee">force_inline</a> <span class="keywordtype">int</span> <a name="a1"></a><a class="code" href="../../d6/d90/strings_8h.html#a60f4bacff9fe077e6c6faf499a00b509">_ast_strlen_zero</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a name="a2"></a><a class="code" href="../../d2/dc8/namespacemake__ari__stubs.html#a40a5d58ffa6e88aa578d6683ac413105">file</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">function</span>, <span class="keywordtype">int</span> line)</div><div class="line">{</div><div class="line">   <span class="keywordflow">if</span> (!s || (*s == <span class="charliteral">&#39;\0&#39;</span>)) {</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">   }</div><div class="line">   <span class="keywordflow">if</span> (!strcmp(s, <span class="stringliteral">&quot;(null)&quot;</span>)) {</div><div class="line">      <a name="a3"></a><a class="code" href="../../da/df7/astobj2_8c.html#a96a00b3a518d7f32b6d51dc28f09bf9b">ast_log</a>(<a name="a4"></a><a class="code" href="../../d1/d8c/logger_8h.html#abdaf681117cfed901932cc0d38f1447a">__LOG_WARNING</a>, file, line, <span class="keyword">function</span>, <span class="stringliteral">&quot;Possible programming error: \&quot;(null)\&quot; is not NULL!\n&quot;</span>);</div><div class="line">   }</div><div class="line">   <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="keyword">static</span> <a class="code" href="../../d4/dd1/compiler_8h.html#ae8c57c7218a376f10cbdf0e50f1189ee">force_inline</a> <span class="keywordtype">int</span> <a name="a5"></a><a class="code" href="../../d4/dd1/compiler_8h.html#a74d759b292a027618339fab3574b9175">attribute_pure</a> <a name="a6"></a><a class="code" href="../../d6/d90/strings_8h.html#a372554b7a2d69a8bd3adac5157672036">ast_strlen_zero</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s)</div><div class="line">{</div><div class="line">   <span class="keywordflow">return</span> (!s || (*s == <span class="charliteral">&#39;\0&#39;</span>));</div><div class="line">}</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef SENSE_OF_HUMOR</span></div><div class="line"><span class="preprocessor">#define ast_strlen_real(a) (a) ? strlen(a) : 0</span></div><div class="line"><span class="preprocessor">#define ast_strlen_imaginary(a)  ast_random()</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*! \brief returns the equivalent of logic or for strings:</span></div><div class="line"><span class="comment"> * first one if not empty, otherwise second one.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="preprocessor">#define S_OR(a, b) ({typeof(&amp;((a)[0])) __x = (a); ast_strlen_zero(__x) ? (b) : __x;})</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*! \brief returns the equivalent of logic or for strings, with an additional boolean check:</span></div><div class="line"><span class="comment"> * second one if not empty and first one is true, otherwise third one.</span></div><div class="line"><span class="comment"> * example: S_COR(usewidget, widget, &quot;&lt;no widget&gt;&quot;)</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="preprocessor">#define S_COR(a, b, c) ({typeof(&amp;((b)[0])) __x = (b); (a) &amp;&amp; !ast_strlen_zero(__x) ? (__x) : (c);})</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">  \brief Checks whether a string begins with another.</span></div><div class="line"><span class="comment">  \since 12.0.0</span></div><div class="line"><span class="comment">  \param str String to check.</span></div><div class="line"><span class="comment">  \param prefix Prefix to look for.</span></div><div class="line"><span class="comment">  \param 1 if \a str begins with \a prefix, 0 otherwise.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="../../d4/dd1/compiler_8h.html#ae8c57c7218a376f10cbdf0e50f1189ee">force_inline</a> <a class="code" href="../../d4/dd1/compiler_8h.html#a74d759b292a027618339fab3574b9175">attribute_pure</a> <a name="a7"></a><a class="code" href="../../d6/d90/strings_8h.html#ac51fa66c90ce950b248c9ff3e8c4e453">ast_begins_with</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a name="a8"></a><a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a name="a9"></a><a class="code" href="../../dd/d43/http_8c.html#a6f25bc812d09fedb86bf394c01061c56">prefix</a>)</div><div class="line">{</div><div class="line">   <a name="a10"></a><a class="code" href="../../d5/d60/utils_8h.html#a24374da24af1931d8a7ccde5b352bb2c">ast_assert</a>(<a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a> != <a name="a11"></a><a class="code" href="../../dc/d7f/resample_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>);</div><div class="line">   <a class="code" href="../../d5/d60/utils_8h.html#a24374da24af1931d8a7ccde5b352bb2c">ast_assert</a>(prefix != <a class="code" href="../../dc/d7f/resample_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>);</div><div class="line">   <span class="keywordflow">while</span> (*<a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a> == *prefix &amp;&amp; *prefix != <span class="charliteral">&#39;\0&#39;</span>) {</div><div class="line">      ++<a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>;</div><div class="line">      ++<a class="code" href="../../dd/d43/http_8c.html#a6f25bc812d09fedb86bf394c01061c56">prefix</a>;</div><div class="line">   }</div><div class="line">   <span class="keywordflow">return</span> *prefix == <span class="charliteral">&#39;\0&#39;</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">  \brief Checks whether a string ends with another.</span></div><div class="line"><span class="comment">  \since 12.0.0</span></div><div class="line"><span class="comment">  \param str String to check.</span></div><div class="line"><span class="comment">  \param suffix Suffix to look for.</span></div><div class="line"><span class="comment">  \param 1 if \a str ends with \a suffix, 0 otherwise.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="../../d4/dd1/compiler_8h.html#ae8c57c7218a376f10cbdf0e50f1189ee">force_inline</a> <a class="code" href="../../d4/dd1/compiler_8h.html#a74d759b292a027618339fab3574b9175">attribute_pure</a> <a name="a12"></a><a class="code" href="../../d6/d90/strings_8h.html#a58dc754cbd6253d7955714f4d058a138">ast_ends_with</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *suffix)</div><div class="line">{</div><div class="line">   <span class="keywordtype">size_t</span> str_len;</div><div class="line">   <span class="keywordtype">size_t</span> suffix_len;</div><div class="line"></div><div class="line">   <a class="code" href="../../d5/d60/utils_8h.html#a24374da24af1931d8a7ccde5b352bb2c">ast_assert</a>(<a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a> != <a class="code" href="../../dc/d7f/resample_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>);</div><div class="line">   <a class="code" href="../../d5/d60/utils_8h.html#a24374da24af1931d8a7ccde5b352bb2c">ast_assert</a>(suffix != <a class="code" href="../../dc/d7f/resample_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>);</div><div class="line">   str_len = strlen(<a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>);</div><div class="line">   suffix_len = strlen(suffix);</div><div class="line"></div><div class="line">   <span class="keywordflow">if</span> (suffix_len &gt; str_len) {</div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keywordflow">return</span> strcmp(<a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a> + str_len - suffix_len, suffix) == 0;</div><div class="line">}</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \brief return Yes or No depending on the argument.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Note that this macro is used my AMI, where a literal &quot;Yes&quot; and &quot;No&quot; are</span></div><div class="line"><span class="comment"> * expected, and translations would cause problems.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \param x Boolean value</span></div><div class="line"><span class="comment"> * \return &quot;Yes&quot; if x is true (non-zero)</span></div><div class="line"><span class="comment"> * \return &quot;No&quot; if x is false (zero)</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="preprocessor">#define AST_YESNO(x) ((x) ? &quot;Yes&quot; : &quot;No&quot;)</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment">  \brief Gets a pointer to the first non-whitespace character in a string.</span></div><div class="line"><span class="comment">  \param str the input string</span></div><div class="line"><span class="comment">  \return a pointer to the first non-whitespace character</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><a name="a13"></a><a class="code" href="../../d5/d9d/inline__api_8h.html#abf50cd4e5859e17bb3d199b805df8fe0">AST_INLINE_API</a>(</div><div class="line"><span class="keywordtype">char</span> * <a class="code" href="../../d4/dd1/compiler_8h.html#a74d759b292a027618339fab3574b9175">attribute_pure</a> <a name="a14"></a><a class="code" href="../../d6/d90/strings_8h.html#af5693da955fa3bc73bc49c47b601fc7a">ast_skip_blanks</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>),</div><div class="line">{</div><div class="line">   <span class="keywordflow">if</span> (<a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>) {</div><div class="line">      <span class="keywordflow">while</span> (*<a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a> &amp;&amp; ((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) *<a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>) &lt; 33) {</div><div class="line">         str++;</div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keywordflow">return</span> (<span class="keywordtype">char</span> *) <a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>;</div><div class="line">}</div><div class="line">)</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment">  \brief Trims trailing whitespace characters from a string.</span></div><div class="line"><span class="comment">  \param str the input string</span></div><div class="line"><span class="comment">  \return a pointer to the modified string</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><a class="code" href="../../d5/d9d/inline__api_8h.html#abf50cd4e5859e17bb3d199b805df8fe0">AST_INLINE_API</a>(</div><div class="line"><span class="keywordtype">char</span> *<a name="a15"></a><a class="code" href="../../d6/d90/strings_8h.html#abe38193be148775f7559f8fff6e0c17e">ast_trim_blanks</a>(<span class="keywordtype">char</span> *<a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>),</div><div class="line">{</div><div class="line">   <span class="keywordtype">char</span> *work = <a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>;</div><div class="line"></div><div class="line">   <span class="keywordflow">if</span> (work) {</div><div class="line">      work += strlen(work) - 1;</div><div class="line">      <span class="comment">/* It&#39;s tempting to only want to erase after we exit this loop,</span></div><div class="line"><span class="comment">         but since ast_trim_blanks *could* receive a constant string</span></div><div class="line"><span class="comment">         (which we presumably wouldn&#39;t have to touch), we shouldn&#39;t</span></div><div class="line"><span class="comment">         actually set anything unless we must, and it&#39;s easier just</span></div><div class="line"><span class="comment">         to set each position to \0 than to keep track of a variable</span></div><div class="line"><span class="comment">         for it */</span></div><div class="line">      <span class="keywordflow">while</span> ((work &gt;= <a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>) &amp;&amp; ((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) *work) &lt; 33)</div><div class="line">         *(work--) = <span class="charliteral">&#39;\0&#39;</span>;</div><div class="line">   }</div><div class="line">   <span class="keywordflow">return</span> <a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>;</div><div class="line">}</div><div class="line">)</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment">  \brief Gets a pointer to first whitespace character in a string.</span></div><div class="line"><span class="comment">  \param str the input string</span></div><div class="line"><span class="comment">  \return a pointer to the first whitespace character</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><a class="code" href="../../d5/d9d/inline__api_8h.html#abf50cd4e5859e17bb3d199b805df8fe0">AST_INLINE_API</a>(</div><div class="line"><span class="keywordtype">char</span> * <a class="code" href="../../d4/dd1/compiler_8h.html#a74d759b292a027618339fab3574b9175">attribute_pure</a> <a name="a16"></a><a class="code" href="../../d6/d90/strings_8h.html#a0734e172f7ec5c8b5ed5ba0737874083">ast_skip_nonblanks</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>),</div><div class="line">{</div><div class="line">   <span class="keywordflow">if</span> (<a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>) {</div><div class="line">      <span class="keywordflow">while</span> (*<a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a> &amp;&amp; ((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) *<a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>) &gt; 32) {</div><div class="line">         str++;</div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keywordflow">return</span> (<span class="keywordtype">char</span> *) <a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>;</div><div class="line">}</div><div class="line">)</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment">  \brief Strip leading/trailing whitespace from a string.</span></div><div class="line"><span class="comment">  \param s The string to be stripped (will be modified).</span></div><div class="line"><span class="comment">  \return The stripped string.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  This functions strips all leading and trailing whitespace</span></div><div class="line"><span class="comment">  characters from the input string, and returns a pointer to</span></div><div class="line"><span class="comment">  the resulting string. The string is modified in place.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><a class="code" href="../../d5/d9d/inline__api_8h.html#abf50cd4e5859e17bb3d199b805df8fe0">AST_INLINE_API</a>(</div><div class="line"><span class="keywordtype">char</span> *<a name="a17"></a><a class="code" href="../../d6/d90/strings_8h.html#ac92713b8d07a45720b2664be70810e55">ast_strip</a>(<span class="keywordtype">char</span> *s),</div><div class="line">{</div><div class="line">   <span class="keywordflow">if</span> ((s = <a class="code" href="../../d6/d90/strings_8h.html#af5693da955fa3bc73bc49c47b601fc7a">ast_skip_blanks</a>(s))) {</div><div class="line">      <a class="code" href="../../d6/d90/strings_8h.html#abe38193be148775f7559f8fff6e0c17e">ast_trim_blanks</a>(s);</div><div class="line">   }</div><div class="line">   <span class="keywordflow">return</span> s;</div><div class="line">}</div><div class="line">)</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment">  \brief Strip leading/trailing whitespace and quotes from a string.</span></div><div class="line"><span class="comment">  \param s The string to be stripped (will be modified).</span></div><div class="line"><span class="comment">  \param beg_quotes The list of possible beginning quote characters.</span></div><div class="line"><span class="comment">  \param end_quotes The list of matching ending quote characters.</span></div><div class="line"><span class="comment">  \return The stripped string.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  This functions strips all leading and trailing whitespace</span></div><div class="line"><span class="comment">  characters from the input string, and returns a pointer to</span></div><div class="line"><span class="comment">  the resulting string. The string is modified in place.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  It can also remove beginning and ending quote (or quote-like)</span></div><div class="line"><span class="comment">  characters, in matching pairs. If the first character of the</span></div><div class="line"><span class="comment">  string matches any character in beg_quotes, and the last</span></div><div class="line"><span class="comment">  character of the string is the matching character in</span></div><div class="line"><span class="comment">  end_quotes, then they are removed from the string.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  Examples:</span></div><div class="line"><span class="comment">  \code</span></div><div class="line"><span class="comment">  ast_strip_quoted(buf, &quot;\&quot;&quot;, &quot;\&quot;&quot;);</span></div><div class="line"><span class="comment">  ast_strip_quoted(buf, &quot;&#39;&quot;, &quot;&#39;&quot;);</span></div><div class="line"><span class="comment">  ast_strip_quoted(buf, &quot;[{(&quot;, &quot;]})&quot;);</span></div><div class="line"><span class="comment">  \endcode</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">char</span> *<a name="a18"></a><a class="code" href="../../d6/d90/strings_8h.html#aeb597bdc9a1209c2e7dd8af04de43485">ast_strip_quoted</a>(<span class="keywordtype">char</span> *s, <span class="keyword">const</span> <span class="keywordtype">char</span> *beg_quotes, <span class="keyword">const</span> <span class="keywordtype">char</span> *end_quotes);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment">  \brief Flags for ast_strsep</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">enum</span> <a class="code" href="../../d6/d90/strings_8h.html#a6b26879ddbe135cabc07822b019b0b17">ast_strsep_flags</a> {</div><div class="line">   <a name="a19"></a><a class="code" href="../../d6/d90/strings_8h.html#a6b26879ddbe135cabc07822b019b0b17ad5a39d9c273e14503b5edc1c8541ebe2">AST_STRSEP_STRIP</a> =    0x01, <span class="comment">/*!&lt; Trim, then strip quotes.  You may want to trim again */</span></div><div class="line">   <a name="a20"></a><a class="code" href="../../d6/d90/strings_8h.html#a6b26879ddbe135cabc07822b019b0b17a81540e33a76fd4c5ca8e4462588e578f">AST_STRSEP_TRIM</a> =     0x02, <span class="comment">/*!&lt; Trim leading and trailing whitespace */</span></div><div class="line">   <a name="a21"></a><a class="code" href="../../d6/d90/strings_8h.html#a6b26879ddbe135cabc07822b019b0b17ac7c24020f292d706a96a93889f3983b2">AST_STRSEP_UNESCAPE</a> = 0x04, <span class="comment">/*!&lt; Unescape &#39;\&#39; */</span></div><div class="line">   <a name="a22"></a><a class="code" href="../../d6/d90/strings_8h.html#a6b26879ddbe135cabc07822b019b0b17a120b93b0f069a2bb5aa60aed14bfb8d0">AST_STRSEP_ALL</a> =      0x07, <span class="comment">/*!&lt; Trim, strip, unescape */</span></div><div class="line">};</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment">  \brief Act like strsep but ignore separators inside quotes.</span></div><div class="line"><span class="comment">  \param s Pointer to address of the string to be processed.</span></div><div class="line"><span class="comment">  Will be modified and can&#39;t be constant.</span></div><div class="line"><span class="comment">  \param sep A single character delimiter.</span></div><div class="line"><span class="comment">  \param flags Controls post-processing of the result.</span></div><div class="line"><span class="comment">  AST_STRSEP_TRIM trims all leading and trailing whitespace from the result.</span></div><div class="line"><span class="comment">  AST_STRSEP_STRIP does a trim then strips the outermost quotes.  You may want</span></div><div class="line"><span class="comment">  to trim again after the strip.  Just OR both the TRIM and STRIP flags.</span></div><div class="line"><span class="comment">  AST_STRSEP_UNESCAPE unescapes &#39;\&#39; sequences.</span></div><div class="line"><span class="comment">  AST_STRSEP_ALL does all of the above processing.</span></div><div class="line"><span class="comment">  \return The next token or NULL if done or if there are more than 8 levels of</span></div><div class="line"><span class="comment">  nested quotes.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  This function acts like strsep with three exceptions...</span></div><div class="line"><span class="comment">  The separator is a single character instead of a string.</span></div><div class="line"><span class="comment">  Separators inside quotes are treated literally instead of like separators.</span></div><div class="line"><span class="comment">  You can elect to have leading and trailing whitespace and quotes</span></div><div class="line"><span class="comment">  stripped from the result and have &#39;\&#39; sequences unescaped.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  Like strsep, ast_strsep maintains no internal state and you can call it</span></div><div class="line"><span class="comment">  recursively using different separators on the same storage.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  Also like strsep, for consistent results, consecutive separators are not</span></div><div class="line"><span class="comment">  collapsed so you may get an empty string as a valid result.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  Examples:</span></div><div class="line"><span class="comment">  \code</span></div><div class="line"><span class="comment">   char *mystr = ast_strdupa(&quot;abc=def,ghi=&#39;zzz=yyy,456&#39;,jkl&quot;);</span></div><div class="line"><span class="comment">   char *token, *token2, *token3;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">   while((token = ast_strsep(&amp;mystr, &#39;,&#39;, AST_SEP_STRIP))) {</span></div><div class="line"><span class="comment">      // 1st token will be aaa=def</span></div><div class="line"><span class="comment">      // 2nd token will be ghi=&#39;zzz=yyy,456&#39;</span></div><div class="line"><span class="comment">      while((token2 = ast_strsep(&amp;token, &#39;=&#39;, AST_SEP_STRIP))) {</span></div><div class="line"><span class="comment">         // 1st token2 will be ghi</span></div><div class="line"><span class="comment">         // 2nd token2 will be zzz=yyy,456</span></div><div class="line"><span class="comment">         while((token3 = ast_strsep(&amp;token2, &#39;,&#39;, AST_SEP_STRIP))) {</span></div><div class="line"><span class="comment">            // 1st token3 will be zzz=yyy</span></div><div class="line"><span class="comment">            // 2nd token3 will be 456</span></div><div class="line"><span class="comment">            // and so on</span></div><div class="line"><span class="comment">         }</span></div><div class="line"><span class="comment">      }</span></div><div class="line"><span class="comment">      // 3rd token will be jkl</span></div><div class="line"><span class="comment">   }</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  \endcode</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">char</span> *<a name="a23"></a><a class="code" href="../../d6/d90/strings_8h.html#aec193d64a6309c72d72e5e523ef6076e">ast_strsep</a>(<span class="keywordtype">char</span> **s, <span class="keyword">const</span> <span class="keywordtype">char</span> sep, uint32_t flags);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment">  \brief Strip backslash for &quot;escaped&quot; semicolons,</span></div><div class="line"><span class="comment">   the string to be stripped (will be modified).</span></div><div class="line"><span class="comment">  \return The stripped string.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">char</span> *<a name="a24"></a><a class="code" href="../../d6/d90/strings_8h.html#a20ca5b03887fb1ecf589590182f4a9aa">ast_unescape_semicolon</a>(<span class="keywordtype">char</span> *s);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment">  \brief Convert some C escape sequences  \verbatim (\b\f\n\r\t) \endverbatim into the</span></div><div class="line"><span class="comment">   equivalent characters. The string to be converted (will be modified).</span></div><div class="line"><span class="comment">  \return The converted string.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">char</span> *<a name="a25"></a><a class="code" href="../../d6/d90/strings_8h.html#a9468c7f63f6497c0ec571c5a34e906d2">ast_unescape_c</a>(<span class="keywordtype">char</span> *s);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \brief Escape the &#39;to_escape&#39; characters in the given string.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \note The given output buffer will contain a truncated escaped</span></div><div class="line"><span class="comment"> * version of the source string if the given buffer is not large</span></div><div class="line"><span class="comment"> * enough.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \param dest the escaped string</span></div><div class="line"><span class="comment"> * \param s the source string to escape</span></div><div class="line"><span class="comment"> * \param size The size of the destination buffer</span></div><div class="line"><span class="comment"> * \param to_escape an array of characters to escape</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \return Pointer to the destination.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">char</span> *<a name="a26"></a><a class="code" href="../../d6/d90/strings_8h.html#a74d504bc3094ec99b1618a1c41b68e19">ast_escape</a>(<span class="keywordtype">char</span> *dest, <span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keywordtype">size_t</span> size, <span class="keyword">const</span> <span class="keywordtype">char</span> *to_escape);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \brief Escape standard &#39;C&#39; sequences in the given string.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \note The given output buffer will contain a truncated escaped</span></div><div class="line"><span class="comment"> * version of the source string if the given buffer is not large</span></div><div class="line"><span class="comment"> * enough.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \param dest the escaped string</span></div><div class="line"><span class="comment"> * \param s the source string to escape</span></div><div class="line"><span class="comment"> * \param size The size of the destination buffer</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \return Pointer to the escaped string.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">char</span> *<a name="a27"></a><a class="code" href="../../d6/d90/strings_8h.html#a365aacee32b2b6eb95f871376cf2aeec">ast_escape_c</a>(<span class="keywordtype">char</span> *dest, <span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keywordtype">size_t</span> size);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \brief Escape the &#39;to_escape&#39; characters in the given string.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \note Caller is responsible for freeing the returned string</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \param s the source string to escape</span></div><div class="line"><span class="comment"> * \param to_escape an array of characters to escape</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \return Pointer to the escaped string or NULL.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">char</span> *<a name="a28"></a><a class="code" href="../../d6/d90/strings_8h.html#a292ef9ea10c2bda74db29c6c60add439">ast_escape_alloc</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keyword">const</span> <span class="keywordtype">char</span> *to_escape);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \brief Escape standard &#39;C&#39; sequences in the given string.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \note Caller is responsible for freeing the returned string</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \param s the source string to escape</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \return Pointer to the escaped string or NULL.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">char</span> *<a name="a29"></a><a class="code" href="../../d6/d90/strings_8h.html#a62bd9f69e2bd9ccd3760d9681987eca0">ast_escape_c_alloc</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment">  \brief Size-limited null-terminating string copy.</span></div><div class="line"><span class="comment">  \param dst The destination buffer.</span></div><div class="line"><span class="comment">  \param src The source string</span></div><div class="line"><span class="comment">  \param size The size of the destination buffer</span></div><div class="line"><span class="comment">  \return Nothing.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  This is similar to \a strncpy, with two important differences:</span></div><div class="line"><span class="comment">    - the destination buffer will \b always be null-terminated</span></div><div class="line"><span class="comment">    - the destination buffer is not filled with zeros past the copied string length</span></div><div class="line"><span class="comment">  These differences make it slightly more efficient, and safer to use since it will</span></div><div class="line"><span class="comment">  not leave the destination buffer unterminated. There is no need to pass an artificially</span></div><div class="line"><span class="comment">  reduced buffer size to this function (unlike \a strncpy), and the buffer does not need</span></div><div class="line"><span class="comment">  to be initialized to zeroes prior to calling this function.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><a class="code" href="../../d5/d9d/inline__api_8h.html#abf50cd4e5859e17bb3d199b805df8fe0">AST_INLINE_API</a>(</div><div class="line"><span class="keywordtype">void</span> <a name="a30"></a><a class="code" href="../../d6/d90/strings_8h.html#ac4040268f7b6ed77dfc49c7767626369">ast_copy_string</a>(<span class="keywordtype">char</span> *dst, <span class="keyword">const</span> <span class="keywordtype">char</span> *src, <span class="keywordtype">size_t</span> size),</div><div class="line">{</div><div class="line">   <span class="keywordflow">while</span> (*src &amp;&amp; size) {</div><div class="line">      *dst++ = *src++;</div><div class="line">      size--;</div><div class="line">   }</div><div class="line">   <span class="keywordflow">if</span> (__builtin_expect(!size, 0))</div><div class="line">      dst--;</div><div class="line">   *dst = <span class="charliteral">&#39;\0&#39;</span>;</div><div class="line">}</div><div class="line">)</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment">  \brief Build a string in a buffer, designed to be called repeatedly</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  \note This method is not recommended. New code should use ast_str_*() instead.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  This is a wrapper for snprintf, that properly handles the buffer pointer</span></div><div class="line"><span class="comment">  and buffer space available.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  \param buffer current position in buffer to place string into (will be updated on return)</span></div><div class="line"><span class="comment">  \param space remaining space in buffer (will be updated on return)</span></div><div class="line"><span class="comment">  \param fmt printf-style format string</span></div><div class="line"><span class="comment">  \retval 0 on success</span></div><div class="line"><span class="comment">  \retval non-zero on failure.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keywordtype">int</span> <a name="a31"></a><a class="code" href="../../d6/d90/strings_8h.html#a603020160399d4876ec09fd299ebcaf9">ast_build_string</a>(<span class="keywordtype">char</span> **buffer, <span class="keywordtype">size_t</span> *space, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, ...) __attribute__((<a name="a32"></a><a class="code" href="../../da/d45/chan__alsa_8c.html#a98f5e70e98f6dc48e3c5ba316066d540">format</a>(printf, 3, 4)));</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment">  \brief Build a string in a buffer, designed to be called repeatedly</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  This is a wrapper for snprintf, that properly handles the buffer pointer</span></div><div class="line"><span class="comment">  and buffer space available.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  \return 0 on success, non-zero on failure.</span></div><div class="line"><span class="comment">  \param buffer current position in buffer to place string into (will be updated on return)</span></div><div class="line"><span class="comment">  \param space remaining space in buffer (will be updated on return)</span></div><div class="line"><span class="comment">  \param fmt printf-style format string</span></div><div class="line"><span class="comment">  \param ap varargs list of arguments for format</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keywordtype">int</span> <a name="a33"></a><a class="code" href="../../d6/d90/strings_8h.html#a7cc2336f3642ec07be6058e7fa746e71">ast_build_string_va</a>(<span class="keywordtype">char</span> **buffer, <span class="keywordtype">size_t</span> *space, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, va_list ap) __attribute__((<a class="code" href="../../da/d45/chan__alsa_8c.html#a98f5e70e98f6dc48e3c5ba316066d540">format</a>(printf, 3, 0)));</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \brief Make sure something is true.</span></div><div class="line"><span class="comment"> * Determine if a string containing a boolean value is &quot;true&quot;.</span></div><div class="line"><span class="comment"> * This function checks to see whether a string passed to it is an indication of an &quot;true&quot; value.</span></div><div class="line"><span class="comment"> * It checks to see if the string is &quot;yes&quot;, &quot;true&quot;, &quot;y&quot;, &quot;t&quot;, &quot;on&quot; or &quot;1&quot;.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \retval 0 if val is a NULL pointer.</span></div><div class="line"><span class="comment"> * \retval -1 if &quot;true&quot;.</span></div><div class="line"><span class="comment"> * \retval 0 otherwise.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="../../d4/dd1/compiler_8h.html#a74d759b292a027618339fab3574b9175">attribute_pure</a> <a name="a34"></a><a class="code" href="../../d6/d90/strings_8h.html#a387a69b3871ca31061566a73f45d20f4">ast_true</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a name="_a35"></a><a class="code" href="../../d5/d85/structval.html">val</a>);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \brief Make sure something is false.</span></div><div class="line"><span class="comment"> * Determine if a string containing a boolean value is &quot;false&quot;.</span></div><div class="line"><span class="comment"> * This function checks to see whether a string passed to it is an indication of an &quot;false&quot; value.</span></div><div class="line"><span class="comment"> * It checks to see if the string is &quot;no&quot;, &quot;false&quot;, &quot;n&quot;, &quot;f&quot;, &quot;off&quot; or &quot;0&quot;.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \retval 0 if val is a NULL pointer.</span></div><div class="line"><span class="comment"> * \retval -1 if &quot;true&quot;.</span></div><div class="line"><span class="comment"> * \retval 0 otherwise.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="../../d4/dd1/compiler_8h.html#a74d759b292a027618339fab3574b9175">attribute_pure</a> <a name="a36"></a><a class="code" href="../../d6/d90/strings_8h.html#a6c3dc0bad204e9dd9890325c1c861e38">ast_false</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="../../d5/d85/structval.html">val</a>);</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * \brief Join an array of strings into a single string.</span></div><div class="line"><span class="comment"> * \param s the resulting string buffer</span></div><div class="line"><span class="comment"> * \param len the length of the result buffer, s</span></div><div class="line"><span class="comment"> * \param w an array of strings to join.</span></div><div class="line"><span class="comment"> * \param size the number of elements to join</span></div><div class="line"><span class="comment"> * \param delim delimiter between elements</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This function will join all of the strings in the array &#39;w&#39; into a single</span></div><div class="line"><span class="comment"> * string.  It will also place &#39;delim&#39; in the result buffer in between each</span></div><div class="line"><span class="comment"> * string from &#39;w&#39;.</span></div><div class="line"><span class="comment"> * \since 12</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keywordtype">void</span> <a name="a37"></a><a class="code" href="../../d6/d90/strings_8h.html#afb2b3d060d0cd9d92c91800c9d582ac9">ast_join_delim</a>(<span class="keywordtype">char</span> *s, <span class="keywordtype">size_t</span> <a name="a38"></a><a class="code" href="../../d9/d1e/func__strings_8c.html#af24e73aaf92f3000fda15d285e66df24">len</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span> w[],</div><div class="line">          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size, <span class="keywordtype">char</span> delim);</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * \brief Join an array of strings into a single string.</span></div><div class="line"><span class="comment"> * \param s the resulting string buffer</span></div><div class="line"><span class="comment"> * \param len the length of the result buffer, s</span></div><div class="line"><span class="comment"> * \param w an array of strings to join.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This function will join all of the strings in the array &#39;w&#39; into a single</span></div><div class="line"><span class="comment"> * string.  It will also place a space in the result buffer in between each</span></div><div class="line"><span class="comment"> * string from &#39;w&#39;.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="preprocessor">#define ast_join(s, len, w) ast_join_delim(s, len, w, -1, &#39; &#39;)</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * \brief Attempts to convert the given string to camel case using</span></div><div class="line"><span class="comment"> *        the specified delimiter.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * note - returned string needs to be freed</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \param s the string to convert</span></div><div class="line"><span class="comment"> * \param delim delimiter to parse out</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \retval The string converted to &quot;CamelCase&quot;</span></div><div class="line"><span class="comment"> * \since 12</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keywordtype">char</span> *<a name="a39"></a><a class="code" href="../../d6/d90/strings_8h.html#ab1f08732bd824bcae476843187180755">ast_to_camel_case_delim</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keyword">const</span> <span class="keywordtype">char</span> *delim);</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * \brief Attempts to convert the given string to camel case using</span></div><div class="line"><span class="comment"> *        an underscore as the specified delimiter.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * note - returned string needs to be freed</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \param s the string to convert</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \retval The string converted to &quot;CamelCase&quot;</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="preprocessor">#define ast_to_camel_case(s) ast_to_camel_case_delim(s, &quot;_&quot;)</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">  \brief Parse a time (integer) string.</span></div><div class="line"><span class="comment">  \param src String to parse</span></div><div class="line"><span class="comment">  \param dst Destination</span></div><div class="line"><span class="comment">  \param _default Value to use if the string does not contain a valid time</span></div><div class="line"><span class="comment">  \param consumed The number of characters &#39;consumed&#39; in the string by the parse (see &#39;man sscanf&#39; for details)</span></div><div class="line"><span class="comment">  \retval 0 on success</span></div><div class="line"><span class="comment">  \retval non-zero on failure.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keywordtype">int</span> <a name="a40"></a><a class="code" href="../../d6/d90/strings_8h.html#a3b5457e5f5679935093d94b0f788769e">ast_get_time_t</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *src, time_t *dst, time_t _default, <span class="keywordtype">int</span> *consumed);</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">  \brief Parse a time (float) string.</span></div><div class="line"><span class="comment">  \param src String to parse</span></div><div class="line"><span class="comment">  \param dst Destination</span></div><div class="line"><span class="comment">  \param _default Value to use if the string does not contain a valid time</span></div><div class="line"><span class="comment">  \param consumed The number of characters &#39;consumed&#39; in the string by the parse (see &#39;man sscanf&#39; for details)</span></div><div class="line"><span class="comment">  \return zero on success, non-zero on failure</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keywordtype">int</span> <a name="a41"></a><a class="code" href="../../d6/d90/strings_8h.html#af96aa9b71c6ef0f2f75038669d950b31">ast_get_timeval</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *src, <span class="keyword">struct</span> timeval *tv, <span class="keyword">struct</span> timeval _default, <span class="keywordtype">int</span> *consumed);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * Support for dynamic strings.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * A dynamic string is just a C string prefixed by a few control fields</span></div><div class="line"><span class="comment"> * that help setting/appending/extending it using a printf-like syntax.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * One should never declare a variable with this type, but only a pointer</span></div><div class="line"><span class="comment"> * to it, e.g.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * struct ast_str *ds;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The pointer can be initialized with the following:</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ds = ast_str_create(init_len);</span></div><div class="line"><span class="comment"> *    creates a malloc()&#39;ed dynamic string;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ds = ast_str_alloca(init_len);</span></div><div class="line"><span class="comment"> *    creates a string on the stack (not very dynamic!).</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ds = ast_str_thread_get(ts, init_len)</span></div><div class="line"><span class="comment"> *    creates a malloc()&#39;ed dynamic string associated to</span></div><div class="line"><span class="comment"> *    the thread-local storage key ts</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Finally, the string can be manipulated with the following:</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ast_str_set(&amp;buf, max_len, fmt, ...)</span></div><div class="line"><span class="comment"> * ast_str_append(&amp;buf, max_len, fmt, ...)</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * and their varargs variant</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ast_str_set_va(&amp;buf, max_len, ap)</span></div><div class="line"><span class="comment"> * ast_str_append_va(&amp;buf, max_len, ap)</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \param max_len The maximum allowed capacity of the ast_str. Note that</span></div><div class="line"><span class="comment"> *  if the value of max_len is less than the current capacity of the</span></div><div class="line"><span class="comment"> *  ast_str (as returned by ast_str_size), then the parameter is effectively</span></div><div class="line"><span class="comment"> *  ignored.</span></div><div class="line"><span class="comment"> *    0 means unlimited, -1 means &quot;at most the available space&quot;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \return All the functions return &lt;0 in case of error, or the</span></div><div class="line"><span class="comment"> * length of the string added to the buffer otherwise. Note that</span></div><div class="line"><span class="comment"> * in most cases where an error is returned, characters ARE written</span></div><div class="line"><span class="comment"> * to the ast_str.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*! \brief The descriptor of a dynamic string</span></div><div class="line"><span class="comment"> *  XXX storage will be optimized later if needed</span></div><div class="line"><span class="comment"> * We use the ts field to indicate the type of storage.</span></div><div class="line"><span class="comment"> * Three special constants indicate malloc, ast_alloca() or static</span></div><div class="line"><span class="comment"> * variables, all other values indicate a</span></div><div class="line"><span class="comment"> * struct ast_threadstorage pointer.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">struct </span><a name="_a42"></a><a class="code" href="../../dd/da2/structast__str.html">ast_str</a> {</div><div class="line">   <span class="keywordtype">size_t</span> <a name="a43"></a><a class="code" href="../../dd/da2/structast__str.html#aa267a036c77c703cb494286a049d624b">__AST_STR_LEN</a>;         <span class="comment">/*!&lt; The current maximum length of the string */</span></div><div class="line">   <span class="keywordtype">size_t</span> <a name="a44"></a><a class="code" href="../../dd/da2/structast__str.html#a7acf1b4de87eb325127bcbb90be35d71">__AST_STR_USED</a>;        <span class="comment">/*!&lt; Amount of space used */</span></div><div class="line">   <span class="keyword">struct </span><a name="_a45"></a><a class="code" href="../../dd/d17/structast__threadstorage.html">ast_threadstorage</a> *<a name="a46"></a><a class="code" href="../../dd/da2/structast__str.html#ac0f4c76f6cddc0e88aeb69e414b10017">__AST_STR_TS</a>;   <span class="comment">/*!&lt; What kind of storage is this ? */</span></div><div class="line"><span class="preprocessor">#define DS_MALLOC ((struct ast_threadstorage *)1)</span></div><div class="line"><span class="preprocessor">#define DS_ALLOCA ((struct ast_threadstorage *)2)</span></div><div class="line"><span class="preprocessor">#define DS_STATIC ((struct ast_threadstorage *)3)  </span><span class="comment">/* not supported yet */</span><span class="preprocessor"></span></div><div class="line">   <span class="keywordtype">char</span> <a name="a47"></a><a class="code" href="../../dd/da2/structast__str.html#a502643f03592ad00c4216e337a27b3d8">__AST_STR_STR</a>[0];        <span class="comment">/*!&lt; The string buffer */</span></div><div class="line">};</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \brief Given a string regex_string in the form of &quot;/regex/&quot;, convert it into the form of &quot;regex&quot;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This function will trim one leading / and one trailing / from a given input string</span></div><div class="line"><span class="comment"> * ast_str regex_pattern must be preallocated before calling this function</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \return 0 on success, non-zero on failure.</span></div><div class="line"><span class="comment"> * \return 1 if we only stripped a leading /</span></div><div class="line"><span class="comment"> * \return 2 if we only stripped a trailing /</span></div><div class="line"><span class="comment"> * \return 3 if we did not strip any / characters</span></div><div class="line"><span class="comment"> * \param regex_string  the string containing /regex/</span></div><div class="line"><span class="comment"> * \param regex_pattern the destination ast_str which will contain &quot;regex&quot; after execution</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">int</span> <a name="a48"></a><a class="code" href="../../d6/d90/strings_8h.html#af7a2c1bf0a98df4a52ee48a9d9e25510">ast_regex_string_to_regex_pattern</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *regex_string, <span class="keyword">struct</span> <a class="code" href="../../dd/da2/structast__str.html">ast_str</a> **regex_pattern);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \brief Create a malloc&#39;ed dynamic length string</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \param init_len This is the initial length of the string buffer</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \return This function returns a pointer to the dynamic string length.  The</span></div><div class="line"><span class="comment"> *         result will be NULL in the case of a memory allocation error.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \note The result of this function is dynamically allocated memory, and must</span></div><div class="line"><span class="comment"> *       be free()&#39;d after it is no longer needed.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="preprocessor">#define ast_str_create(init_len) \</span></div><div class="line"><span class="preprocessor">   _ast_str_create(init_len, __FILE__, __LINE__, __PRETTY_FUNCTION__)</span></div><div class="line"><a class="code" href="../../d5/d9d/inline__api_8h.html#abf50cd4e5859e17bb3d199b805df8fe0">AST_INLINE_API</a>(</div><div class="line"><span class="keyword">struct</span> <a class="code" href="../../dd/da2/structast__str.html">ast_str</a> * <a name="a49"></a><a class="code" href="../../d4/dd1/compiler_8h.html#a6cac3cc05c63f4c86b87adb783c8d620">attribute_malloc</a> <a name="a50"></a><a class="code" href="../../d6/d90/strings_8h.html#ae93e7cd0e9e7a93e399ec01dd48a7201">_ast_str_create</a>(<span class="keywordtype">size_t</span> init_len,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="../../d2/dc8/namespacemake__ari__stubs.html#a40a5d58ffa6e88aa578d6683ac413105">file</a>, <span class="keywordtype">int</span> lineno, <span class="keyword">const</span> <span class="keywordtype">char</span> *func),</div><div class="line">{</div><div class="line">   <span class="keyword">struct </span><a class="code" href="../../dd/da2/structast__str.html">ast_str</a> *<a name="a51"></a><a class="code" href="../../dd/d7c/eagi__proxy_8c.html#ac95651d79c608a3148973b5b1fc9e525">buf</a>;</div><div class="line"></div><div class="line">   buf = (<span class="keyword">struct </span><a class="code" href="../../dd/da2/structast__str.html">ast_str</a> *)<a name="a52"></a><a class="code" href="../../d8/d8a/astmm_8h.html#aacec2637e88f8663d609047874c6661b">__ast_calloc</a>(1, <span class="keyword">sizeof</span>(*buf) + init_len, <a class="code" href="../../d2/dc8/namespacemake__ari__stubs.html#a40a5d58ffa6e88aa578d6683ac413105">file</a>, lineno, func);</div><div class="line">   <span class="keywordflow">if</span> (buf == <a class="code" href="../../dc/d7f/resample_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="../../dc/d7f/resample_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div><div class="line"></div><div class="line">   buf-&gt;<a class="code" href="../../dd/da2/structast__str.html#aa267a036c77c703cb494286a049d624b">__AST_STR_LEN</a> = init_len;</div><div class="line">   buf-&gt;<a class="code" href="../../dd/da2/structast__str.html#a7acf1b4de87eb325127bcbb90be35d71">__AST_STR_USED</a> = 0;</div><div class="line">   buf-&gt;<a class="code" href="../../dd/da2/structast__str.html#ac0f4c76f6cddc0e88aeb69e414b10017">__AST_STR_TS</a> = <a name="a53"></a><a class="code" href="../../d6/d90/strings_8h.html#a20edb6e0de35eafa94d8fd658b6269b5">DS_MALLOC</a>;</div><div class="line"></div><div class="line">   <span class="keywordflow">return</span> <a class="code" href="../../dd/d7c/eagi__proxy_8c.html#ac95651d79c608a3148973b5b1fc9e525">buf</a>;</div><div class="line">}</div><div class="line">)</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*! \brief Reset the content of a dynamic string.</span></div><div class="line"><span class="comment"> * Useful before a series of ast_str_append.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><a class="code" href="../../d5/d9d/inline__api_8h.html#abf50cd4e5859e17bb3d199b805df8fe0">AST_INLINE_API</a>(</div><div class="line"><span class="keywordtype">void</span> <a name="a54"></a><a class="code" href="../../d6/d90/strings_8h.html#a8239b9ad10367bfc936e9b60ff7706a8">ast_str_reset</a>(<span class="keyword">struct</span> <a class="code" href="../../dd/da2/structast__str.html">ast_str</a> *<a class="code" href="../../dd/d7c/eagi__proxy_8c.html#ac95651d79c608a3148973b5b1fc9e525">buf</a>),</div><div class="line">{</div><div class="line">   <span class="keywordflow">if</span> (buf) {</div><div class="line">      buf-&gt;<a class="code" href="../../dd/da2/structast__str.html#a7acf1b4de87eb325127bcbb90be35d71">__AST_STR_USED</a> = 0;</div><div class="line">      <span class="keywordflow">if</span> (buf-&gt;<a class="code" href="../../dd/da2/structast__str.html#aa267a036c77c703cb494286a049d624b">__AST_STR_LEN</a>) {</div><div class="line">         buf-&gt;<a class="code" href="../../dd/da2/structast__str.html#a502643f03592ad00c4216e337a27b3d8">__AST_STR_STR</a>[0] = <span class="charliteral">&#39;\0&#39;</span>;</div><div class="line">      }</div><div class="line">   }</div><div class="line">}</div><div class="line">)</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*! \brief Update the length of the buffer, after using ast_str merely as a buffer.</span></div><div class="line"><span class="comment"> *  \param buf A pointer to the ast_str string.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><a class="code" href="../../d5/d9d/inline__api_8h.html#abf50cd4e5859e17bb3d199b805df8fe0">AST_INLINE_API</a>(</div><div class="line"><span class="keywordtype">void</span> <a name="a55"></a><a class="code" href="../../d6/d90/strings_8h.html#aa64825674476f476402283fe4bd7ee51">ast_str_update</a>(<span class="keyword">struct</span> <a class="code" href="../../dd/da2/structast__str.html">ast_str</a> *buf),</div><div class="line">{</div><div class="line">   buf-&gt;<a class="code" href="../../dd/da2/structast__str.html#a7acf1b4de87eb325127bcbb90be35d71">__AST_STR_USED</a> = strlen(buf-&gt;<a class="code" href="../../dd/da2/structast__str.html#a502643f03592ad00c4216e337a27b3d8">__AST_STR_STR</a>);</div><div class="line">}</div><div class="line">)</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*! \brief Trims trailing whitespace characters from an ast_str string.</span></div><div class="line"><span class="comment"> *  \param buf A pointer to the ast_str string.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><a class="code" href="../../d5/d9d/inline__api_8h.html#abf50cd4e5859e17bb3d199b805df8fe0">AST_INLINE_API</a>(</div><div class="line"><span class="keywordtype">void</span> <a name="a56"></a><a class="code" href="../../d6/d90/strings_8h.html#a6a44a14b43688738c2d526b776f6230f">ast_str_trim_blanks</a>(<span class="keyword">struct</span> <a class="code" href="../../dd/da2/structast__str.html">ast_str</a> *buf),</div><div class="line">{</div><div class="line">   <span class="keywordflow">if</span> (!buf) {</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line">   }</div><div class="line">   <span class="keywordflow">while</span> (buf-&gt;<a class="code" href="../../dd/da2/structast__str.html#a7acf1b4de87eb325127bcbb90be35d71">__AST_STR_USED</a> &amp;&amp; ((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) buf-&gt;<a class="code" href="../../dd/da2/structast__str.html#a502643f03592ad00c4216e337a27b3d8">__AST_STR_STR</a>[buf-&gt;<a class="code" href="../../dd/da2/structast__str.html#a7acf1b4de87eb325127bcbb90be35d71">__AST_STR_USED</a> - 1]) &lt; 33) {</div><div class="line">      buf-&gt;<a class="code" href="../../dd/da2/structast__str.html#a502643f03592ad00c4216e337a27b3d8">__AST_STR_STR</a>[--(buf-&gt;<a class="code" href="../../dd/da2/structast__str.html#a7acf1b4de87eb325127bcbb90be35d71">__AST_STR_USED</a>)] = <span class="charliteral">&#39;\0&#39;</span>;</div><div class="line">   }</div><div class="line">}</div><div class="line">)</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!\brief Returns the current length of the string stored within buf.</span></div><div class="line"><span class="comment"> * \param buf A pointer to the ast_str structure.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><a class="code" href="../../d5/d9d/inline__api_8h.html#abf50cd4e5859e17bb3d199b805df8fe0">AST_INLINE_API</a>(</div><div class="line"><span class="keywordtype">size_t</span> <a class="code" href="../../d4/dd1/compiler_8h.html#a74d759b292a027618339fab3574b9175">attribute_pure</a> <a name="a57"></a><a class="code" href="../../d6/d90/strings_8h.html#aabc005bd1c7e249e8f8659d57d4500b6">ast_str_strlen</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="../../dd/da2/structast__str.html">ast_str</a> *buf),</div><div class="line">{</div><div class="line">   <span class="keywordflow">return</span> buf-&gt;<a class="code" href="../../dd/da2/structast__str.html#a7acf1b4de87eb325127bcbb90be35d71">__AST_STR_USED</a>;</div><div class="line">}</div><div class="line">)</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!\brief Returns the current maximum length (without reallocation) of the current buffer.</span></div><div class="line"><span class="comment"> * \param buf A pointer to the ast_str structure.</span></div><div class="line"><span class="comment"> * \retval Current maximum length of the buffer.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><a class="code" href="../../d5/d9d/inline__api_8h.html#abf50cd4e5859e17bb3d199b805df8fe0">AST_INLINE_API</a>(</div><div class="line"><span class="keywordtype">size_t</span> <a class="code" href="../../d4/dd1/compiler_8h.html#a74d759b292a027618339fab3574b9175">attribute_pure</a> <a name="a58"></a><a class="code" href="../../d6/d90/strings_8h.html#ae99d6f51ac4be6b72f8b63892cd949e1">ast_str_size</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="../../dd/da2/structast__str.html">ast_str</a> *buf),</div><div class="line">{</div><div class="line">   <span class="keywordflow">return</span> buf-&gt;<a class="code" href="../../dd/da2/structast__str.html#aa267a036c77c703cb494286a049d624b">__AST_STR_LEN</a>;</div><div class="line">}</div><div class="line">)</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!\brief Returns the string buffer within the ast_str buf.</span></div><div class="line"><span class="comment"> * \param buf A pointer to the ast_str structure.</span></div><div class="line"><span class="comment"> * \retval A pointer to the enclosed string.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><a class="code" href="../../d5/d9d/inline__api_8h.html#abf50cd4e5859e17bb3d199b805df8fe0">AST_INLINE_API</a>(</div><div class="line"><span class="keywordtype">char</span> * <a class="code" href="../../d4/dd1/compiler_8h.html#a74d759b292a027618339fab3574b9175">attribute_pure</a> <a name="a59"></a><a class="code" href="../../d6/d90/strings_8h.html#a1ef7e2644ca7258070db316fdc0a465b">ast_str_buffer</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="../../dd/da2/structast__str.html">ast_str</a> *buf),</div><div class="line">{</div><div class="line">   <span class="comment">/* for now, cast away the const qualifier on the pointer</span></div><div class="line"><span class="comment">    * being returned; eventually, it should become truly const</span></div><div class="line"><span class="comment">    * and only be modified via accessor functions</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keywordflow">return</span> (<span class="keywordtype">char</span> *) buf-&gt;<a class="code" href="../../dd/da2/structast__str.html#a502643f03592ad00c4216e337a27b3d8">__AST_STR_STR</a>;</div><div class="line">}</div><div class="line">)</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!\brief Truncates the enclosed string to the given length.</span></div><div class="line"><span class="comment"> * \param buf A pointer to the ast_str structure.</span></div><div class="line"><span class="comment"> * \param len Maximum length of the string. If len is larger than the</span></div><div class="line"><span class="comment"> *        current maximum length, things will explode. If it is negative</span></div><div class="line"><span class="comment"> *        at most -len characters will be trimmed off the end.</span></div><div class="line"><span class="comment"> * \retval A pointer to the resulting string.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><a class="code" href="../../d5/d9d/inline__api_8h.html#abf50cd4e5859e17bb3d199b805df8fe0">AST_INLINE_API</a>(</div><div class="line"><span class="keywordtype">char</span> *<a name="a60"></a><a class="code" href="../../d6/d90/strings_8h.html#a0b9c195ff2235f7670358e1e37cf6b8d">ast_str_truncate</a>(<span class="keyword">struct</span> <a class="code" href="../../dd/da2/structast__str.html">ast_str</a> *buf, ssize_t <a class="code" href="../../d9/d1e/func__strings_8c.html#af24e73aaf92f3000fda15d285e66df24">len</a>),</div><div class="line">{</div><div class="line">   <span class="keywordflow">if</span> (<a class="code" href="../../d9/d1e/func__strings_8c.html#af24e73aaf92f3000fda15d285e66df24">len</a> &lt; 0) {</div><div class="line">      <span class="keywordflow">if</span> ((<a name="a61"></a><a class="code" href="../../de/df7/time_8h.html#a0726afc816122530dfd83ecf14901ff2">typeof</a>(buf-&gt;<a class="code" href="../../dd/da2/structast__str.html#a7acf1b4de87eb325127bcbb90be35d71">__AST_STR_USED</a>)) -<a class="code" href="../../d9/d1e/func__strings_8c.html#af24e73aaf92f3000fda15d285e66df24">len</a> &gt;= buf-&gt;<a class="code" href="../../dd/da2/structast__str.html#a7acf1b4de87eb325127bcbb90be35d71">__AST_STR_USED</a>) {</div><div class="line">         buf-&gt;<a class="code" href="../../dd/da2/structast__str.html#a7acf1b4de87eb325127bcbb90be35d71">__AST_STR_USED</a> = 0;</div><div class="line">      } <span class="keywordflow">else</span> {</div><div class="line">         buf-&gt;<a class="code" href="../../dd/da2/structast__str.html#a7acf1b4de87eb325127bcbb90be35d71">__AST_STR_USED</a> += <a class="code" href="../../d9/d1e/func__strings_8c.html#af24e73aaf92f3000fda15d285e66df24">len</a>;</div><div class="line">      }</div><div class="line">   } <span class="keywordflow">else</span> {</div><div class="line">      buf-&gt;<a class="code" href="../../dd/da2/structast__str.html#a7acf1b4de87eb325127bcbb90be35d71">__AST_STR_USED</a> = <a class="code" href="../../d9/d1e/func__strings_8c.html#af24e73aaf92f3000fda15d285e66df24">len</a>;</div><div class="line">   }</div><div class="line">   buf-&gt;<a class="code" href="../../dd/da2/structast__str.html#a502643f03592ad00c4216e337a27b3d8">__AST_STR_STR</a>[buf-&gt;<a class="code" href="../../dd/da2/structast__str.html#a7acf1b4de87eb325127bcbb90be35d71">__AST_STR_USED</a>] = <span class="charliteral">&#39;\0&#39;</span>;</div><div class="line">   <span class="keywordflow">return</span> buf-&gt;<a class="code" href="../../dd/da2/structast__str.html#a502643f03592ad00c4216e337a27b3d8">__AST_STR_STR</a>;</div><div class="line">}</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * AST_INLINE_API() is a macro that takes a block of code as an argument.</span></div><div class="line"><span class="comment"> * Using preprocessor #directives in the argument is not supported by all</span></div><div class="line"><span class="comment"> * compilers, and it is a bit of an obfuscation anyways, so avoid it.</span></div><div class="line"><span class="comment"> * As a workaround, define a macro that produces either its argument</span></div><div class="line"><span class="comment"> * or nothing, and use that instead of #ifdef/#endif within the</span></div><div class="line"><span class="comment"> * argument to AST_INLINE_API().</span></div><div class="line"><span class="comment"> */</span></div><div class="line">#<span class="keywordflow">if</span> defined(DEBUG_THREADLOCALS)</div><div class="line"><span class="preprocessor">#define  _DB1(x)  x</span></div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="preprocessor">#define _DB1(x)</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * Make space in a new string (e.g. to read in data from a file)</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><a class="code" href="../../d5/d9d/inline__api_8h.html#abf50cd4e5859e17bb3d199b805df8fe0">AST_INLINE_API</a>(</div><div class="line"><span class="keywordtype">int</span> <a name="a62"></a><a class="code" href="../../d6/d90/strings_8h.html#a384eba533216f3d2741cc8a51bc66987">_ast_str_make_space</a>(<span class="keyword">struct</span> <a class="code" href="../../dd/da2/structast__str.html">ast_str</a> **buf, <span class="keywordtype">size_t</span> new_len, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="../../d2/dc8/namespacemake__ari__stubs.html#a40a5d58ffa6e88aa578d6683ac413105">file</a>, <span class="keywordtype">int</span> lineno, <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">function</span>),</div><div class="line">{</div><div class="line">   <span class="keyword">struct </span><a class="code" href="../../dd/da2/structast__str.html">ast_str</a> *old_buf = *<a class="code" href="../../dd/d7c/eagi__proxy_8c.html#ac95651d79c608a3148973b5b1fc9e525">buf</a>;</div><div class="line"></div><div class="line">   <span class="keywordflow">if</span> (new_len &lt;= (*buf)-&gt;__AST_STR_LEN)</div><div class="line">      <span class="keywordflow">return</span> 0;   <span class="comment">/* success */</span></div><div class="line">   <a name="a63"></a><a class="code" href="../../dc/df2/ast__expr2f_8c.html#a33e91cd0cef6786e9e3a27ac67707207">if</a> ((*buf)-&gt;__AST_STR_TS == <a name="a64"></a><a class="code" href="../../d6/d90/strings_8h.html#a6156c625587998a6612dbba274c860f7">DS_ALLOCA</a> || (*buf)-&gt;__AST_STR_TS == <a name="a65"></a><a class="code" href="../../d6/d90/strings_8h.html#a507890094a4eb5180fdf417988fbdee0">DS_STATIC</a>)</div><div class="line">      <span class="keywordflow">return</span> -1;  <span class="comment">/* cannot extend */</span></div><div class="line">   *buf = (<span class="keyword">struct</span> <a class="code" href="../../dd/da2/structast__str.html">ast_str</a> *)<a name="a66"></a><a class="code" href="../../d8/d8a/astmm_8h.html#a6fb2a532b8ed08d248b7326abf218c5e">__ast_realloc</a>(*buf, new_len + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="../../dd/da2/structast__str.html">ast_str</a>), <a class="code" href="../../d2/dc8/namespacemake__ari__stubs.html#a40a5d58ffa6e88aa578d6683ac413105">file</a>, lineno, <span class="keyword">function</span>);</div><div class="line">   <span class="keywordflow">if</span> (*buf == <a class="code" href="../../dc/d7f/resample_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {</div><div class="line">      *buf = old_buf;</div><div class="line">      <span class="keywordflow">return</span> -1;</div><div class="line">   }</div><div class="line">   <span class="keywordflow">if</span> ((*buf)-&gt;__AST_STR_TS != <a class="code" href="../../d6/d90/strings_8h.html#a20edb6e0de35eafa94d8fd658b6269b5">DS_MALLOC</a>) {</div><div class="line">      pthread_setspecific((*buf)-&gt;__AST_STR_TS-&gt;key, *buf);</div><div class="line">      _DB1(__ast_threadstorage_object_replace(old_buf, *buf, new_len + sizeof(struct ast_str));)</div><div class="line">   }</div><div class="line"></div><div class="line">   (*buf)-&gt;<a class="code" href="../../dd/da2/structast__str.html#aa267a036c77c703cb494286a049d624b">__AST_STR_LEN</a> = new_len;</div><div class="line">   <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line">)</div><div class="line">#define <a name="a67"></a><a class="code" href="../../d6/d90/strings_8h.html#aa3d67163f6a94e575ee602933adf1eab">ast_str_make_space</a>(buf, new_len) \</div><div class="line">   _ast_str_make_space(buf, new_len, __FILE__, __LINE__, __PRETTY_FUNCTION__)</div><div class="line"></div><div class="line"><a class="code" href="../../d5/d9d/inline__api_8h.html#abf50cd4e5859e17bb3d199b805df8fe0">AST_INLINE_API</a>(</div><div class="line"><span class="keywordtype">int</span> <a name="a68"></a><a class="code" href="../../d6/d90/strings_8h.html#a592839be18ac3eb7e7207d89f682f9ac">ast_str_copy_string</a>(<span class="keyword">struct</span> <a class="code" href="../../dd/da2/structast__str.html">ast_str</a> **dst, <span class="keyword">struct</span> <a class="code" href="../../dd/da2/structast__str.html">ast_str</a> *src),</div><div class="line">{</div><div class="line"></div><div class="line">   <span class="comment">/* make sure our destination is large enough */</span></div><div class="line">   <span class="keywordflow">if</span> (src-&gt;<a class="code" href="../../dd/da2/structast__str.html#a7acf1b4de87eb325127bcbb90be35d71">__AST_STR_USED</a> + 1 &gt; (*dst)-&gt;__AST_STR_LEN) {</div><div class="line">      if (ast_str_make_space(dst, src-&gt;__AST_STR_USED + 1)) {</div><div class="line">         return -1;</div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   memcpy((*dst)-&gt;__AST_STR_STR, src-&gt;<a class="code" href="../../dd/da2/structast__str.html#a502643f03592ad00c4216e337a27b3d8">__AST_STR_STR</a>, src-&gt;<a class="code" href="../../dd/da2/structast__str.html#a7acf1b4de87eb325127bcbb90be35d71">__AST_STR_USED</a> + 1);</div><div class="line">   (*dst)-&gt;__AST_STR_USED = src-&gt;<a class="code" href="../../dd/da2/structast__str.html#a7acf1b4de87eb325127bcbb90be35d71">__AST_STR_USED</a>;</div><div class="line">   <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line">)</div><div class="line"></div><div class="line">#define <a name="a69"></a><a class="code" href="../../d6/d90/strings_8h.html#a7fc844c12b769ccded05e7514036e241">ast_str_alloca</a>(init_len)       \</div><div class="line">   ({                \</div><div class="line">      struct <a class="code" href="../../dd/da2/structast__str.html">ast_str</a> *__ast_str_buf;         \</div><div class="line">      __ast_str_buf = <a name="a70"></a><a class="code" href="../../d8/d8a/astmm_8h.html#a249282ecc7ba5a1a49fa75e9a33d1717">ast_alloca</a>(<span class="keyword">sizeof</span>(*__ast_str_buf) + init_len); \</div><div class="line">      __ast_str_buf-&gt;__AST_STR_LEN = init_len;        \</div><div class="line">      __ast_str_buf-&gt;__AST_STR_USED = 0;           \</div><div class="line">      __ast_str_buf-&gt;__AST_STR_TS = <a class="code" href="../../d6/d90/strings_8h.html#a6156c625587998a6612dbba274c860f7">DS_ALLOCA</a>;        \</div><div class="line">      __ast_str_buf-&gt;__AST_STR_STR[0] = <span class="charliteral">&#39;\0&#39;</span>;         \</div><div class="line">      (__ast_str_buf);              \</div><div class="line">   })</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \brief Retrieve a thread locally stored dynamic string</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \param ts This is a pointer to the thread storage structure declared by using</span></div><div class="line"><span class="comment"> *      the AST_THREADSTORAGE macro.  If declared with</span></div><div class="line"><span class="comment"> *      AST_THREADSTORAGE(my_buf, my_buf_init), then this argument would be</span></div><div class="line"><span class="comment"> *      (&amp;my_buf).</span></div><div class="line"><span class="comment"> * \param init_len This is the initial length of the thread&#39;s dynamic string. The</span></div><div class="line"><span class="comment"> *      current length may be bigger if previous operations in this thread have</span></div><div class="line"><span class="comment"> *      caused it to increase.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \return This function will return the thread locally stored dynamic string</span></div><div class="line"><span class="comment"> *         associated with the thread storage management variable passed as the</span></div><div class="line"><span class="comment"> *         first argument.</span></div><div class="line"><span class="comment"> *         The result will be NULL in the case of a memory allocation error.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Example usage:</span></div><div class="line"><span class="comment"> * \code</span></div><div class="line"><span class="comment"> * AST_THREADSTORAGE(my_str, my_str_init);</span></div><div class="line"><span class="comment"> * #define MY_STR_INIT_SIZE   128</span></div><div class="line"><span class="comment"> * ...</span></div><div class="line"><span class="comment"> * void my_func(const char *fmt, ...)</span></div><div class="line"><span class="comment"> * {</span></div><div class="line"><span class="comment"> *      struct ast_str *buf;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *      if (!(buf = ast_str_thread_get(&amp;my_str, MY_STR_INIT_SIZE)))</span></div><div class="line"><span class="comment"> *           return;</span></div><div class="line"><span class="comment"> *      ...</span></div><div class="line"><span class="comment"> * }</span></div><div class="line"><span class="comment"> * \endcode</span></div><div class="line"><span class="comment"> */</span></div><div class="line">#<span class="keywordflow">if</span> !defined(DEBUG_THREADLOCALS)</div><div class="line"><a class="code" href="../../d5/d9d/inline__api_8h.html#abf50cd4e5859e17bb3d199b805df8fe0">AST_INLINE_API</a>(</div><div class="line"><span class="keyword">struct</span> <a class="code" href="../../dd/da2/structast__str.html">ast_str</a> *<a name="a71"></a><a class="code" href="../../d6/d90/strings_8h.html#afe8f5f844f2fd5f5bd5d0be5ef671481">ast_str_thread_get</a>(<span class="keyword">struct</span> <a class="code" href="../../dd/d17/structast__threadstorage.html">ast_threadstorage</a> *ts,</div><div class="line">   <span class="keywordtype">size_t</span> init_len),</div><div class="line">{</div><div class="line">   <span class="keyword">struct </span><a class="code" href="../../dd/da2/structast__str.html">ast_str</a> *<a class="code" href="../../dd/d7c/eagi__proxy_8c.html#ac95651d79c608a3148973b5b1fc9e525">buf</a>;</div><div class="line"></div><div class="line">   buf = (<span class="keyword">struct </span><a class="code" href="../../dd/da2/structast__str.html">ast_str</a> *)<a name="a72"></a><a class="code" href="../../dc/d7d/threadstorage_8h.html#ab6ff44d2acf6ea45090177cd3141da03">ast_threadstorage_get</a>(ts, <span class="keyword">sizeof</span>(*buf) + init_len);</div><div class="line">   <span class="keywordflow">if</span> (buf == <a class="code" href="../../dc/d7f/resample_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="../../dc/d7f/resample_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div><div class="line"></div><div class="line">   <span class="keywordflow">if</span> (!buf-&gt;<a class="code" href="../../dd/da2/structast__str.html#aa267a036c77c703cb494286a049d624b">__AST_STR_LEN</a>) {</div><div class="line">      buf-&gt;<a class="code" href="../../dd/da2/structast__str.html#aa267a036c77c703cb494286a049d624b">__AST_STR_LEN</a> = init_len;</div><div class="line">      buf-&gt;<a class="code" href="../../dd/da2/structast__str.html#a7acf1b4de87eb325127bcbb90be35d71">__AST_STR_USED</a> = 0;</div><div class="line">      buf-&gt;<a class="code" href="../../dd/da2/structast__str.html#ac0f4c76f6cddc0e88aeb69e414b10017">__AST_STR_TS</a> = ts;</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keywordflow">return</span> <a class="code" href="../../dd/d7c/eagi__proxy_8c.html#ac95651d79c608a3148973b5b1fc9e525">buf</a>;</div><div class="line">}</div><div class="line">)</div><div class="line">#<span class="keywordflow">else</span> <span class="comment">/* defined(DEBUG_THREADLOCALS) */</span></div><div class="line"><a class="code" href="../../d5/d9d/inline__api_8h.html#abf50cd4e5859e17bb3d199b805df8fe0">AST_INLINE_API</a>(</div><div class="line"><span class="keyword">struct</span> <a class="code" href="../../dd/da2/structast__str.html">ast_str</a> *__ast_str_thread_get(<span class="keyword">struct</span> <a class="code" href="../../dd/d17/structast__threadstorage.html">ast_threadstorage</a> *ts,</div><div class="line">   <span class="keywordtype">size_t</span> init_len, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="../../d2/dc8/namespacemake__ari__stubs.html#a40a5d58ffa6e88aa578d6683ac413105">file</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">function</span>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> line),</div><div class="line">{</div><div class="line">   <span class="keyword">struct </span><a class="code" href="../../dd/da2/structast__str.html">ast_str</a> *<a class="code" href="../../dd/d7c/eagi__proxy_8c.html#ac95651d79c608a3148973b5b1fc9e525">buf</a>;</div><div class="line"></div><div class="line">   buf = (<span class="keyword">struct </span><a class="code" href="../../dd/da2/structast__str.html">ast_str</a> *)__ast_threadstorage_get(ts, <span class="keyword">sizeof</span>(*buf) + init_len, <a class="code" href="../../d2/dc8/namespacemake__ari__stubs.html#a40a5d58ffa6e88aa578d6683ac413105">file</a>, <span class="keyword">function</span>, line);</div><div class="line">   <span class="keywordflow">if</span> (buf == <a class="code" href="../../dc/d7f/resample_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="../../dc/d7f/resample_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div><div class="line"></div><div class="line">   <span class="keywordflow">if</span> (!buf-&gt;<a class="code" href="../../dd/da2/structast__str.html#aa267a036c77c703cb494286a049d624b">__AST_STR_LEN</a>) {</div><div class="line">      buf-&gt;<a class="code" href="../../dd/da2/structast__str.html#aa267a036c77c703cb494286a049d624b">__AST_STR_LEN</a> = init_len;</div><div class="line">      buf-&gt;<a class="code" href="../../dd/da2/structast__str.html#a7acf1b4de87eb325127bcbb90be35d71">__AST_STR_USED</a> = 0;</div><div class="line">      buf-&gt;<a class="code" href="../../dd/da2/structast__str.html#ac0f4c76f6cddc0e88aeb69e414b10017">__AST_STR_TS</a> = ts;</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keywordflow">return</span> <a class="code" href="../../dd/d7c/eagi__proxy_8c.html#ac95651d79c608a3148973b5b1fc9e525">buf</a>;</div><div class="line">}</div><div class="line">)</div><div class="line"></div><div class="line">#define <a class="code" href="../../d6/d90/strings_8h.html#afe8f5f844f2fd5f5bd5d0be5ef671481">ast_str_thread_get</a>(ts, init_len) __ast_str_thread_get(ts, init_len, __FILE__, __PRETTY_FUNCTION__, __LINE__)</div><div class="line"><span class="preprocessor">#endif </span><span class="comment">/* defined(DEBUG_THREADLOCALS) */</span><span class="preprocessor"></span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \brief Error codes from __ast_str_helper()</span></div><div class="line"><span class="comment"> * The undelying processing to manipulate dynamic string is done</span></div><div class="line"><span class="comment"> * by __ast_str_helper(), which can return a success or a</span></div><div class="line"><span class="comment"> * permanent failure (e.g. no memory).</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">enum</span> {<span class="comment"></span></div><div class="line"><span class="comment">   /*! An error has occurred and the contents of the dynamic string</span></div><div class="line"><span class="comment">    *  are undefined */</span></div><div class="line">   <a name="a73"></a><a class="code" href="../../d6/d90/strings_8h.html#a640e110a8e92c1283f2aae76e4649f48a46fbdfa757aef01471bab9679ce4281f">AST_DYNSTR_BUILD_FAILED</a> = -1,<span class="comment"></span></div><div class="line"><span class="comment">   /*! The buffer size for the dynamic string had to be increased, and</span></div><div class="line"><span class="comment">    *  __ast_str_helper() needs to be called again after</span></div><div class="line"><span class="comment">    *  a va_end() and va_start().  This return value is legacy and will</span></div><div class="line"><span class="comment">    *  no longer be used.</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <a name="a74"></a><a class="code" href="../../d6/d90/strings_8h.html#a640e110a8e92c1283f2aae76e4649f48aebcdc95d7cc2d21815ef0650ee4690e4">AST_DYNSTR_BUILD_RETRY</a> = -2</div><div class="line">};</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \brief Core functionality of ast_str_(set|append)_va</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The arguments to this function are the same as those described for</span></div><div class="line"><span class="comment"> * ast_str_set_va except for an addition argument, append.</span></div><div class="line"><span class="comment"> * If append is non-zero, this will append to the current string instead of</span></div><div class="line"><span class="comment"> * writing over it.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * AST_DYNSTR_BUILD_RETRY is a legacy define.  It should probably never</span></div><div class="line"><span class="comment"> * again be used.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * A return of AST_DYNSTR_BUILD_FAILED indicates a memory allocation error.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * A return value greater than or equal to zero indicates the number of</span></div><div class="line"><span class="comment"> * characters that have been written, not including the terminating &#39;\0&#39;.</span></div><div class="line"><span class="comment"> * In the append case, this only includes the number of characters appended.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \note This function should never need to be called directly.  It should</span></div><div class="line"><span class="comment"> *       through calling one of the other functions or macros defined in this</span></div><div class="line"><span class="comment"> *       file.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">int</span> __attribute__((<a class="code" href="../../da/d45/chan__alsa_8c.html#a98f5e70e98f6dc48e3c5ba316066d540">format</a>(printf, 4, 0))) <a name="a75"></a><a class="code" href="../../d6/d90/strings_8h.html#aa5c07cfa3dd6c6c55b94a4d0dde4ed84">__ast_str_helper</a>(<span class="keyword">struct</span> <a class="code" href="../../dd/da2/structast__str.html">ast_str</a> **buf,</div><div class="line">   ssize_t max_len, <span class="keywordtype">int</span> append, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, va_list ap,</div><div class="line">   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="../../d2/dc8/namespacemake__ari__stubs.html#a40a5d58ffa6e88aa578d6683ac413105">file</a>, <span class="keywordtype">int</span> lineno, <span class="keyword">const</span> <span class="keywordtype">char</span> *func);</div><div class="line"><span class="preprocessor">#define _ast_str_helper(buf, max_len, append, fmt, ap) \</span></div><div class="line"><span class="preprocessor">   __ast_str_helper(buf, max_len, append, fmt, ap, __FILE__, __LINE__, __PRETTY_FUNCTION__)</span></div><div class="line"></div><div class="line"><span class="keywordtype">char</span> *<a name="a76"></a><a class="code" href="../../d6/d90/strings_8h.html#af82174c2859a9cdbd4d19a55ad5f3c94">__ast_str_helper2</a>(<span class="keyword">struct</span> <a class="code" href="../../dd/da2/structast__str.html">ast_str</a> **buf, ssize_t max_len,</div><div class="line">   <span class="keyword">const</span> <span class="keywordtype">char</span> *src, <span class="keywordtype">size_t</span> maxsrc, <span class="keywordtype">int</span> append, <span class="keywordtype">int</span> escapecommas);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \brief Set a dynamic string from a va_list</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \param buf This is the address of a pointer to a struct ast_str.</span></div><div class="line"><span class="comment"> * If it is retrieved using ast_str_thread_get, the</span></div><div class="line"><span class="comment">   struct ast_threadstorage pointer will need to</span></div><div class="line"><span class="comment"> *      be updated in the case that the buffer has to be reallocated to</span></div><div class="line"><span class="comment"> *      accommodate a longer string than what it currently has space for.</span></div><div class="line"><span class="comment"> * \param max_len This is the maximum length to allow the string buffer to grow</span></div><div class="line"><span class="comment"> *      to.  If this is set to 0, then there is no maximum length.</span></div><div class="line"><span class="comment"> * \param fmt This is the format string (printf style)</span></div><div class="line"><span class="comment"> * \param ap This is the va_list</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \return The return value of this function is the same as that of the printf</span></div><div class="line"><span class="comment"> *         family of functions.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Example usage (the first part is only for thread-local storage)</span></div><div class="line"><span class="comment"> * \code</span></div><div class="line"><span class="comment"> * AST_THREADSTORAGE(my_str, my_str_init);</span></div><div class="line"><span class="comment"> * #define MY_STR_INIT_SIZE   128</span></div><div class="line"><span class="comment"> * ...</span></div><div class="line"><span class="comment"> * void my_func(const char *fmt, ...)</span></div><div class="line"><span class="comment"> * {</span></div><div class="line"><span class="comment"> *      struct ast_str *buf;</span></div><div class="line"><span class="comment"> *      va_list ap;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *      if (!(buf = ast_str_thread_get(&amp;my_str, MY_STR_INIT_SIZE)))</span></div><div class="line"><span class="comment"> *           return;</span></div><div class="line"><span class="comment"> *      ...</span></div><div class="line"><span class="comment"> *      va_start(fmt, ap);</span></div><div class="line"><span class="comment"> *      ast_str_set_va(&amp;buf, 0, fmt, ap);</span></div><div class="line"><span class="comment"> *      va_end(ap);</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *      printf(&quot;This is the string we just built: %s\n&quot;, buf-&gt;str);</span></div><div class="line"><span class="comment"> *      ...</span></div><div class="line"><span class="comment"> * }</span></div><div class="line"><span class="comment"> * \endcode</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \note Care should be taken when using this function. The function can</span></div><div class="line"><span class="comment"> * result in reallocating the ast_str. If a pointer to the ast_str is passed</span></div><div class="line"><span class="comment"> * by value to a function that calls ast_str_set_va(), then the original ast_str</span></div><div class="line"><span class="comment"> * pointer may be invalidated due to a reallocation.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><a class="code" href="../../d5/d9d/inline__api_8h.html#abf50cd4e5859e17bb3d199b805df8fe0">AST_INLINE_API</a>(<span class="keywordtype">int</span> __attribute__((<a class="code" href="../../da/d45/chan__alsa_8c.html#a98f5e70e98f6dc48e3c5ba316066d540">format</a>(printf, 3, 0))) <a name="a77"></a><a class="code" href="../../d6/d90/strings_8h.html#a271350c7540474095b75cbea17d4837a">ast_str_set_va</a>(<span class="keyword">struct</span> <a class="code" href="../../dd/da2/structast__str.html">ast_str</a> **buf, ssize_t max_len, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, va_list ap),</div><div class="line">{</div><div class="line">   <span class="keywordflow">return</span> <a name="a78"></a><a class="code" href="../../d6/d90/strings_8h.html#aa7a2cd389095897464c66a10734e5d94">_ast_str_helper</a>(buf, max_len, 0, fmt, ap);</div><div class="line">}</div><div class="line">)</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \brief Append to a dynamic string using a va_list</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Same as ast_str_set_va(), but append to the current content.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \note Care should be taken when using this function. The function can</span></div><div class="line"><span class="comment"> * result in reallocating the ast_str. If a pointer to the ast_str is passed</span></div><div class="line"><span class="comment"> * by value to a function that calls ast_str_append_va(), then the original ast_str</span></div><div class="line"><span class="comment"> * pointer may be invalidated due to a reallocation.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \param buf, max_len, fmt, ap</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><a class="code" href="../../d5/d9d/inline__api_8h.html#abf50cd4e5859e17bb3d199b805df8fe0">AST_INLINE_API</a>(<span class="keywordtype">int</span> __attribute__((<a class="code" href="../../da/d45/chan__alsa_8c.html#a98f5e70e98f6dc48e3c5ba316066d540">format</a>(printf, 3, 0))) <a name="a79"></a><a class="code" href="../../d6/d90/strings_8h.html#aadcedfc19bc7df38193262ebb8f3c991">ast_str_append_va</a>(<span class="keyword">struct</span> <a class="code" href="../../dd/da2/structast__str.html">ast_str</a> **buf, ssize_t max_len, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, va_list ap),</div><div class="line">{</div><div class="line">   <span class="keywordflow">return</span> <a class="code" href="../../d6/d90/strings_8h.html#aa7a2cd389095897464c66a10734e5d94">_ast_str_helper</a>(buf, max_len, 1, fmt, ap);</div><div class="line">}</div><div class="line">)</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!\brief Set a dynamic string to a non-NULL terminated substring. */</span></div><div class="line"><a class="code" href="../../d5/d9d/inline__api_8h.html#abf50cd4e5859e17bb3d199b805df8fe0">AST_INLINE_API</a>(<span class="keywordtype">char</span> *<a name="a80"></a><a class="code" href="../../d6/d90/strings_8h.html#abda810b81f8f0349aca3fad136e5d416">ast_str_set_substr</a>(<span class="keyword">struct</span> <a class="code" href="../../dd/da2/structast__str.html">ast_str</a> **buf, ssize_t maxlen, <span class="keyword">const</span> <span class="keywordtype">char</span> *src, <span class="keywordtype">size_t</span> maxsrc),</div><div class="line">{</div><div class="line">   <span class="keywordflow">return</span> <a class="code" href="../../d6/d90/strings_8h.html#af82174c2859a9cdbd4d19a55ad5f3c94">__ast_str_helper2</a>(buf, maxlen, src, maxsrc, 0, 0);</div><div class="line">}</div><div class="line">)</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!\brief Append a non-NULL terminated substring to the end of a dynamic string. */</span></div><div class="line"><a class="code" href="../../d5/d9d/inline__api_8h.html#abf50cd4e5859e17bb3d199b805df8fe0">AST_INLINE_API</a>(<span class="keywordtype">char</span> *<a name="a81"></a><a class="code" href="../../d6/d90/strings_8h.html#a66daf21afabae2111fb397beb9a6c57e">ast_str_append_substr</a>(<span class="keyword">struct</span> <a class="code" href="../../dd/da2/structast__str.html">ast_str</a> **buf, ssize_t maxlen, <span class="keyword">const</span> <span class="keywordtype">char</span> *src, <span class="keywordtype">size_t</span> maxsrc),</div><div class="line">{</div><div class="line">   <span class="keywordflow">return</span> <a class="code" href="../../d6/d90/strings_8h.html#af82174c2859a9cdbd4d19a55ad5f3c94">__ast_str_helper2</a>(buf, maxlen, src, maxsrc, 1, 0);</div><div class="line">}</div><div class="line">)</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!\brief Set a dynamic string to a non-NULL terminated substring, with escaping of commas. */</span></div><div class="line"><a class="code" href="../../d5/d9d/inline__api_8h.html#abf50cd4e5859e17bb3d199b805df8fe0">AST_INLINE_API</a>(<span class="keywordtype">char</span> *<a name="a82"></a><a class="code" href="../../d6/d90/strings_8h.html#a54efe3bc7af1c934b35ce6a55bdaa4ae">ast_str_set_escapecommas</a>(<span class="keyword">struct</span> <a class="code" href="../../dd/da2/structast__str.html">ast_str</a> **buf, ssize_t maxlen, <span class="keyword">const</span> <span class="keywordtype">char</span> *src, <span class="keywordtype">size_t</span> maxsrc),</div><div class="line">{</div><div class="line">   <span class="keywordflow">return</span> <a class="code" href="../../d6/d90/strings_8h.html#af82174c2859a9cdbd4d19a55ad5f3c94">__ast_str_helper2</a>(buf, maxlen, src, maxsrc, 0, 1);</div><div class="line">}</div><div class="line">)</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!\brief Append a non-NULL terminated substring to the end of a dynamic string, with escaping of commas. */</span></div><div class="line"><a class="code" href="../../d5/d9d/inline__api_8h.html#abf50cd4e5859e17bb3d199b805df8fe0">AST_INLINE_API</a>(<span class="keywordtype">char</span> *<a name="a83"></a><a class="code" href="../../d6/d90/strings_8h.html#a6135d2f0275e692cd2fcbb0144408509">ast_str_append_escapecommas</a>(<span class="keyword">struct</span> <a class="code" href="../../dd/da2/structast__str.html">ast_str</a> **buf, ssize_t maxlen, <span class="keyword">const</span> <span class="keywordtype">char</span> *src, <span class="keywordtype">size_t</span> maxsrc),</div><div class="line">{</div><div class="line">   <span class="keywordflow">return</span> <a class="code" href="../../d6/d90/strings_8h.html#af82174c2859a9cdbd4d19a55ad5f3c94">__ast_str_helper2</a>(buf, maxlen, src, maxsrc, 1, 1);</div><div class="line">}</div><div class="line">)</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \brief Set a dynamic string using variable arguments</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \note Care should be taken when using this function. The function can</span></div><div class="line"><span class="comment"> * result in reallocating the ast_str. If a pointer to the ast_str is passed</span></div><div class="line"><span class="comment"> * by value to a function that calls ast_str_set(), then the original ast_str</span></div><div class="line"><span class="comment"> * pointer may be invalidated due to a reallocation.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \param buf This is the address of a pointer to a struct ast_str which should</span></div><div class="line"><span class="comment"> *      have been retrieved using ast_str_thread_get.  It will need to</span></div><div class="line"><span class="comment"> *      be updated in the case that the buffer has to be reallocated to</span></div><div class="line"><span class="comment"> *      accomodate a longer string than what it currently has space for.</span></div><div class="line"><span class="comment"> * \param max_len This is the maximum length to allow the string buffer to grow</span></div><div class="line"><span class="comment"> *      to.  If this is set to 0, then there is no maximum length.</span></div><div class="line"><span class="comment"> * If set to -1, we are bound to the current maximum length.</span></div><div class="line"><span class="comment"> * \param fmt This is the format string (printf style)</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \return The return value of this function is the same as that of the printf</span></div><div class="line"><span class="comment"> *         family of functions.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * All the rest is the same as ast_str_set_va()</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><a class="code" href="../../d5/d9d/inline__api_8h.html#abf50cd4e5859e17bb3d199b805df8fe0">AST_INLINE_API</a>(</div><div class="line"><span class="keywordtype">int</span> __attribute__((<a class="code" href="../../da/d45/chan__alsa_8c.html#a98f5e70e98f6dc48e3c5ba316066d540">format</a>(printf, 3, 4))) <a name="a84"></a><a class="code" href="../../d6/d90/strings_8h.html#aa3341f35cedca29e60bb7f3927204283">ast_str_set</a>(</div><div class="line">   <span class="keyword">struct</span> <a class="code" href="../../dd/da2/structast__str.html">ast_str</a> **buf, ssize_t max_len, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, ...),</div><div class="line">{</div><div class="line">   <span class="keywordtype">int</span> res;</div><div class="line">   va_list ap;</div><div class="line"></div><div class="line">   va_start(ap, fmt);</div><div class="line">   res = <a class="code" href="../../d6/d90/strings_8h.html#a271350c7540474095b75cbea17d4837a">ast_str_set_va</a>(buf, max_len, fmt, ap);</div><div class="line">   va_end(ap);</div><div class="line"></div><div class="line">   <span class="keywordflow">return</span> res;</div><div class="line">}</div><div class="line">)</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \brief Append to a thread local dynamic string</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \note Care should be taken when using this function. The function can</span></div><div class="line"><span class="comment"> * result in reallocating the ast_str. If a pointer to the ast_str is passed</span></div><div class="line"><span class="comment"> * by value to a function that calls ast_str_append(), then the original ast_str</span></div><div class="line"><span class="comment"> * pointer may be invalidated due to a reallocation.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The arguments, return values, and usage of this function are the same as</span></div><div class="line"><span class="comment"> * ast_str_set(), but the new data is appended to the current value.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><a class="code" href="../../d5/d9d/inline__api_8h.html#abf50cd4e5859e17bb3d199b805df8fe0">AST_INLINE_API</a>(</div><div class="line"><span class="keywordtype">int</span> __attribute__((<a class="code" href="../../da/d45/chan__alsa_8c.html#a98f5e70e98f6dc48e3c5ba316066d540">format</a>(printf, 3, 4))) <a name="a85"></a><a class="code" href="../../d6/d90/strings_8h.html#a1088afdd862a49b0fce34ebe02df8ca1">ast_str_append</a>(</div><div class="line">   <span class="keyword">struct</span> <a class="code" href="../../dd/da2/structast__str.html">ast_str</a> **buf, ssize_t max_len, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, ...),</div><div class="line">{</div><div class="line">   <span class="keywordtype">int</span> res;</div><div class="line">   va_list ap;</div><div class="line"></div><div class="line">   va_start(ap, fmt);</div><div class="line">   res = <a class="code" href="../../d6/d90/strings_8h.html#aadcedfc19bc7df38193262ebb8f3c991">ast_str_append_va</a>(buf, max_len, fmt, ap);</div><div class="line">   va_end(ap);</div><div class="line"></div><div class="line">   <span class="keywordflow">return</span> res;</div><div class="line">}</div><div class="line">)</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \brief Provides a temporary ast_str and returns a copy of its buffer</span></div><div class="line"><span class="comment"> * \since 16.12</span></div><div class="line"><span class="comment"> * \since 17.6</span></div><div class="line"><span class="comment"> * \since 18.0</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \param init_len The initial length of the temporary ast_str needed.</span></div><div class="line"><span class="comment"> * \param __expr An expression that needs the temporary ast_str and returns a char *.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \returns A copy of __expr&#39;s return buffer allocated on the stack.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \details</span></div><div class="line"><span class="comment"> * There are a few query functions scattered around that need an ast_str in which</span></div><div class="line"><span class="comment"> * to assemble the results but it&#39;s not always convenient to create an ast_str</span></div><div class="line"><span class="comment"> * and ensure it&#39;s freed just to print a log message.  For example...</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * struct ast_str *temp = ast_str_create(128);</span></div><div class="line"><span class="comment"> * ast_log(LOG_INFO, &quot;Format caps: %s\n&quot;, ast_format_cap_get_names(caps, &amp;temp));</span></div><div class="line"><span class="comment"> * ast_free(temp);</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * That&#39;s not bad if you only have to do it once but some of our code that deals</span></div><div class="line"><span class="comment"> * with streams and codecs is pretty complex and good instrumentation is essential.</span></div><div class="line"><span class="comment"> * The aim of this function is to make that easier.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * With this macro, the above code can be simplified as follows...</span></div><div class="line"><span class="comment"> * \example</span></div><div class="line"><span class="comment"> * ast_log(LOG_INFO, &quot;Format caps: %s\n&quot;,</span></div><div class="line"><span class="comment"> *     ast_str_tmp(128, ast_format_cap_get_names(caps, &amp;STR_TMP));</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * STR_TMP will always be a reference to the temporary ast_str created</span></div><div class="line"><span class="comment"> * by the macro.  Its scope is limited by the macro so you can use it multiple</span></div><div class="line"><span class="comment"> * times without conflict.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \example</span></div><div class="line"><span class="comment"> * ast_log(LOG_INFO, &quot;Format caps in: %s  Format caps out: %s\n&quot;,</span></div><div class="line"><span class="comment"> *     ast_str_tmp(128, ast_format_cap_get_names(caps_in, &amp;STR_TMP),</span></div><div class="line"><span class="comment"> *     ast_str_tmp(128, ast_format_cap_get_names(caps_out, &amp;STR_TMP)</span></div><div class="line"><span class="comment"> *     );</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \warning</span></div><div class="line"><span class="comment"> * The returned string is stack allocated so don&#39;t go overboard.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> */</span></div><div class="line">#define <a name="a86"></a><a class="code" href="../../d6/d90/strings_8h.html#a68ab38eef5d5958cae536ba7589093cc">ast_str_tmp</a>(init_len, __expr) \</div><div class="line">({ \</div><div class="line">   struct <a class="code" href="../../dd/da2/structast__str.html">ast_str</a> *STR_TMP = <a name="a87"></a><a class="code" href="../../d6/d90/strings_8h.html#a9c34c6c6b8daaba24c0406270f3cf697">ast_str_create</a>(init_len); \</div><div class="line">   char *ret = <a name="a88"></a><a class="code" href="../../d8/d8a/astmm_8h.html#ab5f0750cc80ba337fdcbddea2d3a1ee6">ast_strdupa</a>(__expr); \</div><div class="line">   ast_free(STR_TMP); \</div><div class="line">   ret; \</div><div class="line">})</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \brief Check if a string is only digits</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \retval 1 The string contains only digits</span></div><div class="line"><span class="comment"> * \retval 0 The string contains non-digit characters</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><a class="code" href="../../d5/d9d/inline__api_8h.html#abf50cd4e5859e17bb3d199b805df8fe0">AST_INLINE_API</a>(</div><div class="line"><span class="keywordtype">int</span> <a name="a89"></a><a class="code" href="../../d6/d90/strings_8h.html#aed341efc1f8e4613d59b43a8455aa8a1">ast_check_digits</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *arg),</div><div class="line">{</div><div class="line">   <span class="keywordflow">while</span> (*arg) {</div><div class="line">      <span class="keywordflow">if</span> (*arg &lt; &#39;0&#39; || *arg &gt; <span class="charliteral">&#39;9&#39;</span>) {</div><div class="line">         <span class="keywordflow">return</span> 0;</div><div class="line">      }</div><div class="line">      arg++;</div><div class="line">   }</div><div class="line">   <span class="keywordflow">return</span> 1;</div><div class="line">}</div><div class="line">)</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \brief Convert the tech portion of a device string to upper case</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \retval dev_str Returns the char* passed in for convenience</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><a class="code" href="../../d5/d9d/inline__api_8h.html#abf50cd4e5859e17bb3d199b805df8fe0">AST_INLINE_API</a>(</div><div class="line"><span class="keywordtype">char</span> *<a name="a90"></a><a class="code" href="../../d6/d90/strings_8h.html#a3d00ecafdea681595d840862538266c3">ast_tech_to_upper</a>(<span class="keywordtype">char</span> *dev_str),</div><div class="line">{</div><div class="line">   <span class="keywordtype">char</span> *pos;</div><div class="line">   <span class="keywordflow">if</span> (!dev_str || !strchr(dev_str, <span class="charliteral">&#39;/&#39;</span>)) {</div><div class="line">      <span class="keywordflow">return</span> dev_str;</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keywordflow">for</span> (pos = dev_str; *pos &amp;&amp; *pos != <span class="charliteral">&#39;/&#39;</span>; pos++) {</div><div class="line">      *pos = toupper(*pos);</div><div class="line">   }</div><div class="line">   <span class="keywordflow">return</span> dev_str;</div><div class="line">}</div><div class="line">)</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \brief Restrict hash value range</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \details</span></div><div class="line"><span class="comment"> * Hash values used all over asterisk are expected to be non-negative</span></div><div class="line"><span class="comment"> * (signed) int values.  This function restricts an unsigned int hash</span></div><div class="line"><span class="comment"> * value to the positive half of the (signed) int values.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> <a class="code" href="../../d4/dd1/compiler_8h.html#ae8c57c7218a376f10cbdf0e50f1189ee">force_inline</a> <span class="keywordtype">int</span> <a class="code" href="../../d4/dd1/compiler_8h.html#a74d759b292a027618339fab3574b9175">attribute_pure</a> <a name="a91"></a><a class="code" href="../../d6/d90/strings_8h.html#a7a7eb843162c5e29c59951d07d08fa57">ast_str_hash_restrict</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hash)</div><div class="line">{</div><div class="line">   <span class="keywordflow">return</span> (<span class="keywordtype">int</span>) (hash &amp; (<span class="keywordtype">unsigned</span> int) INT_MAX);</div><div class="line">}</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \brief Compute a hash value on a string</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This famous hash algorithm was written by Dan Bernstein and is</span></div><div class="line"><span class="comment"> * commonly used.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * http://www.cse.yorku.ca/~oz/hash.html</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> <a class="code" href="../../d4/dd1/compiler_8h.html#ae8c57c7218a376f10cbdf0e50f1189ee">force_inline</a> <span class="keywordtype">int</span> <a class="code" href="../../d4/dd1/compiler_8h.html#a74d759b292a027618339fab3574b9175">attribute_pure</a> <a name="a92"></a><a class="code" href="../../d6/d90/strings_8h.html#a33ab7fa091d5513d8507d3bd33ef5b55">ast_str_hash</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>)</div><div class="line">{</div><div class="line">   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hash = 5381;</div><div class="line"></div><div class="line">   <span class="keywordflow">while</span> (*str) {</div><div class="line">      hash = hash * 33 ^ (<span class="keywordtype">unsigned</span> char) *str++;</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keywordflow">return</span> <a class="code" href="../../d6/d90/strings_8h.html#a7a7eb843162c5e29c59951d07d08fa57">ast_str_hash_restrict</a>(hash);</div><div class="line">}</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \brief Compute a hash value on a string</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \param[in] str The string to add to the hash</span></div><div class="line"><span class="comment"> * \param[in] seed The hash value to start with</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \details</span></div><div class="line"><span class="comment"> * This version of the function is for when you need to compute a</span></div><div class="line"><span class="comment"> * string hash of more than one string.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This famous hash algorithm was written by Dan Bernstein and is</span></div><div class="line"><span class="comment"> * commonly used.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \sa http://www.cse.yorku.ca/~oz/hash.html</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> <a class="code" href="../../d4/dd1/compiler_8h.html#ae8c57c7218a376f10cbdf0e50f1189ee">force_inline</a> <span class="keywordtype">int</span> <a name="a93"></a><a class="code" href="../../d6/d90/strings_8h.html#a14f7ad64e77247cbba670a2be4ef76a8">ast_str_hash_add</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>, <span class="keywordtype">int</span> seed)</div><div class="line">{</div><div class="line">   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hash = (<span class="keywordtype">unsigned</span> int) seed;</div><div class="line"></div><div class="line">   <span class="keywordflow">while</span> (*<a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>) {</div><div class="line">      hash = hash * 33 ^ (<span class="keywordtype">unsigned</span> char) *<a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>++;</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keywordflow">return</span> <a class="code" href="../../d6/d90/strings_8h.html#a7a7eb843162c5e29c59951d07d08fa57">ast_str_hash_restrict</a>(hash);</div><div class="line">}</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \brief Compute a hash value on a case-insensitive string</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Uses the same hash algorithm as ast_str_hash, but converts</span></div><div class="line"><span class="comment"> * all characters to lowercase prior to computing a hash. This</span></div><div class="line"><span class="comment"> * allows for easy case-insensitive lookups in a hash table.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> <a class="code" href="../../d4/dd1/compiler_8h.html#ae8c57c7218a376f10cbdf0e50f1189ee">force_inline</a> <span class="keywordtype">int</span> <a class="code" href="../../d4/dd1/compiler_8h.html#a74d759b292a027618339fab3574b9175">attribute_pure</a> <a name="a94"></a><a class="code" href="../../d6/d90/strings_8h.html#ab08f8db2a7258e538a0da7417f58db58">ast_str_case_hash</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>)</div><div class="line">{</div><div class="line">   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hash = 5381;</div><div class="line"></div><div class="line">   <span class="keywordflow">while</span> (*str) {</div><div class="line">      hash = hash * 33 ^ (<span class="keywordtype">unsigned</span> char) tolower(*str++);</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keywordflow">return</span> <a class="code" href="../../d6/d90/strings_8h.html#a7a7eb843162c5e29c59951d07d08fa57">ast_str_hash_restrict</a>(hash);</div><div class="line">}</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \brief Convert a string to all lower-case</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \param str The string to be converted to lower case</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \retval str for convenience</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> <a class="code" href="../../d4/dd1/compiler_8h.html#ae8c57c7218a376f10cbdf0e50f1189ee">force_inline</a> <span class="keywordtype">char</span> *<a name="a95"></a><a class="code" href="../../d6/d90/strings_8h.html#aa8ab574002a6eb04925efea4c2885059">ast_str_to_lower</a>(<span class="keywordtype">char</span> *<a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>)</div><div class="line">{</div><div class="line">   <span class="keywordtype">char</span> *str_orig = <a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>;</div><div class="line">   <span class="keywordflow">if</span> (!str) {</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>;</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keywordflow">for</span> (; *<a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>; ++<a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>) {</div><div class="line">      *str = tolower(*str);</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keywordflow">return</span> str_orig;</div><div class="line">}</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \brief Convert a string to all upper-case</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \param str The string to be converted to upper case</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \retval str for convenience</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> <a class="code" href="../../d4/dd1/compiler_8h.html#ae8c57c7218a376f10cbdf0e50f1189ee">force_inline</a> <span class="keywordtype">char</span> *<a name="a96"></a><a class="code" href="../../d6/d90/strings_8h.html#ae07f46b125b1fc1520b076ff8b8c4ad8">ast_str_to_upper</a>(<span class="keywordtype">char</span> *<a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>)</div><div class="line">{</div><div class="line">   <span class="keywordtype">char</span> *str_orig = <a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>;</div><div class="line">   <span class="keywordflow">if</span> (!str) {</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>;</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keywordflow">for</span> (; *<a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>; ++<a class="code" href="../../de/dcd/app__jack_8c.html#af25d6dc49269fa2003ac7c7fa6f13915">str</a>) {</div><div class="line">      *str = toupper(*str);</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keywordflow">return</span> str_orig;</div><div class="line">}</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \since 12</span></div><div class="line"><span class="comment"> * \brief Allocates a hash container for bare strings</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \param buckets The number of buckets to use for the hash container</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \retval AO2 container for strings</span></div><div class="line"><span class="comment"> * \retval NULL if allocation failed</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="preprocessor">#define ast_str_container_alloc(buckets) ast_str_container_alloc_options(AO2_ALLOC_OPT_LOCK_MUTEX, buckets)</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \since 12</span></div><div class="line"><span class="comment"> * \brief Allocates a hash container for bare strings</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \param opts Options to be provided to the container</span></div><div class="line"><span class="comment"> * \param buckets The number of buckets to use for the hash container</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \retval AO2 container for strings</span></div><div class="line"><span class="comment"> * \retval NULL if allocation failed</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="comment">//struct ao2_container *ast_str_container_alloc_options(enum ao2_container_opts opts, int buckets);</span></div><div class="line"><span class="keyword">struct </span><a name="_a97"></a><a class="code" href="../../d2/da9/structao2__container.html">ao2_container</a> *<a name="a98"></a><a class="code" href="../../d6/d90/strings_8h.html#a6764761a6222d4855cbf6f7abf117015">ast_str_container_alloc_options</a>(<span class="keyword">enum</span> <a class="code" href="../../d5/da5/astobj2_8h.html#a2cf7e3433f08351aafe3b0cd31edf7f8">ao2_alloc_opts</a> opts, <span class="keywordtype">int</span> buckets);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \since 12</span></div><div class="line"><span class="comment"> * \brief Adds a string to a string container allocated by ast_str_container_alloc</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \param str_container The container to which to add a string</span></div><div class="line"><span class="comment"> * \param add The string to add to the container</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \retval zero on success</span></div><div class="line"><span class="comment"> * \retval non-zero if the operation failed</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">int</span> <a name="a99"></a><a class="code" href="../../d6/d90/strings_8h.html#ae2861c04a240bbc90f32ade1e1261afa">ast_str_container_add</a>(<span class="keyword">struct</span> <a class="code" href="../../d2/da9/structao2__container.html">ao2_container</a> *str_container, <span class="keyword">const</span> <span class="keywordtype">char</span> *add);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \since 12</span></div><div class="line"><span class="comment"> * \brief Removes a string from a string container allocated by ast_str_container_alloc</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \param str_container The container from which to remove a string</span></div><div class="line"><span class="comment"> * \param remove The string to remove from the container</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">void</span> <a name="a100"></a><a class="code" href="../../d6/d90/strings_8h.html#ad763671e425c36b3d4c467a32676e0a5">ast_str_container_remove</a>(<span class="keyword">struct</span> <a class="code" href="../../d2/da9/structao2__container.html">ao2_container</a> *str_container, <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">remove</span>);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \brief Create a pseudo-random string of a fixed length.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This function is useful for generating a string whose randomness</span></div><div class="line"><span class="comment"> * does not need to be across all time and space, does not need to</span></div><div class="line"><span class="comment"> * be cryptographically secure, and needs to fit in a limited space.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This function will write a null byte at the final position</span></div><div class="line"><span class="comment"> * in the buffer (buf[size - 1]). So if you pass in a size of</span></div><div class="line"><span class="comment"> * 10, then this will generate a random 9-character string.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \param buf Buffer to write random string into.</span></div><div class="line"><span class="comment"> * \param size The size of the buffer.</span></div><div class="line"><span class="comment"> * \return A pointer to buf</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">char</span> *<a name="a101"></a><a class="code" href="../../d6/d90/strings_8h.html#ab2c8e1bf4b2b01a1ffabf882774907bb">ast_generate_random_string</a>(<span class="keywordtype">char</span> *buf, <span class="keywordtype">size_t</span> size);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \brief Compare strings for equality checking for NULL.</span></div><div class="line"><span class="comment"> * \since 16.3.0</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This function considers NULL values as non-strings, thus a false condition.</span></div><div class="line"><span class="comment"> * This means that it will return false if one, or both of the given values are</span></div><div class="line"><span class="comment"> * NULL (i.e. two NULLs are not equal strings).</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \param str1 The string to compare to str2</span></div><div class="line"><span class="comment"> * \param str2 The string to compare to str1</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \return true if valid strings and equal, false otherwise.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">int</span> <a name="a102"></a><a class="code" href="../../d6/d90/strings_8h.html#a13824dd1c76e6cbb12dd7f7783fca8fd">ast_strings_equal</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *str1, <span class="keyword">const</span> <span class="keywordtype">char</span> *str2);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \brief Compares 2 strings using realtime-style operators</span></div><div class="line"><span class="comment"> * \since 13.9.0</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \param left The left side of the equation</span></div><div class="line"><span class="comment"> * \param op The operator to apply</span></div><div class="line"><span class="comment"> * \param right The right side of the equation</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \retval 1 matches</span></div><div class="line"><span class="comment"> * \retval 0 doesn&#39;t match</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \details</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Operators:</span></div><div class="line"><span class="comment"> *    &quot;=&quot;, &quot;!=&quot;, &quot;&lt;&quot;, &quot;&lt;=&quot;, &quot;&gt;&quot;, &quot;&gt;=&quot;:</span></div><div class="line"><span class="comment"> *       If both left and right can be converted to float, then they will be</span></div><div class="line"><span class="comment"> *       compared as such. Otherwise the result will be derived from strcmp(left, right).</span></div><div class="line"><span class="comment"> * &quot;regex&quot;:</span></div><div class="line"><span class="comment"> *     The right value will be compiled as a regular expression and matched against the left</span></div><div class="line"><span class="comment"> *     value.</span></div><div class="line"><span class="comment"> * &quot;like&quot;:</span></div><div class="line"><span class="comment"> *     Any &#39;%&#39; character in the right value will be converted to &#39;.*&#39; and the resulting</span></div><div class="line"><span class="comment"> *     string will be handled as a regex.</span></div><div class="line"><span class="comment"> * NULL , &quot;&quot;:</span></div><div class="line"><span class="comment"> *     If the right value starts and ends with a &#39;/&#39; then it will be processed as a regex.</span></div><div class="line"><span class="comment"> *     Otherwise, same as &quot;=&quot;.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">int</span> <a name="a103"></a><a class="code" href="../../d6/d90/strings_8h.html#a898b45f9c873eeb3a4917f41332a1414">ast_strings_match</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *left, <span class="keyword">const</span> <span class="keywordtype">char</span> *op, <span class="keyword">const</span> <span class="keywordtype">char</span> *right);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \brief Read lines from a string buffer</span></div><div class="line"><span class="comment"> * \since 13.18.0</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \param buffer [IN/OUT] A pointer to a char * string with either Unix or Windows line endings</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \return The &quot;next&quot; line</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \warning The original string and *buffer will be modified.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \details</span></div><div class="line"><span class="comment"> * Both &#39;\n&#39; and &#39;\r\n&#39; are treated as single delimiters but consecutive occurrances of</span></div><div class="line"><span class="comment"> * the delimiters are NOT considered to be a single delimiter.  This preserves blank</span></div><div class="line"><span class="comment"> * lines in the input.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * MacOS line endings (&#39;\r&#39;) are not supported at this time.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">char</span> *<a name="a104"></a><a class="code" href="../../d6/d90/strings_8h.html#aec9fdc621b97dd7beac3e4a225d11bb6">ast_read_line_from_buffer</a>(<span class="keywordtype">char</span> **buffer);</div><div class="line"></div><div class="line"><span class="preprocessor">#endif </span><span class="comment">/* _ASTERISK_STRINGS_H */</span><span class="preprocessor"></span></div></div><!-- fragment --> </div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 8 2021 19:42:55 for Asterisk - The Open Source Telephony Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
